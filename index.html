<!doctype html>
<html lang="de">
<head>
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ABC‚ÄëAbenteuer ‚Äì H√∂r & Finde (Prototyp)</title>

  <!-- PWA Manifest & Theme -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <meta name="theme-color" content="#5a6ff0">

  <!-- JSZip f√ºr Export/Import -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      --bg:#fff8e7;
      --ink:#2d1b4e;
      --muted:#6b7896;
      --brand:#7c3aed;
      --brand-2:#fb923c;
      --brand-3:#f472b6;
      --ok:#22c55e;
      --bad:#ef4444;
      --surface:#ffffff;
      --card:#ffffff;
      --shadow: 0 12px 40px rgba(124,58,237,.15);
      --radius:20px;
      --radius-sm:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,var(--bg),#fff);
      color:var(--ink);
      font-family: ui-rounded, "SF Pro Rounded", "Segoe UI", "Arial Rounded MT Bold", system-ui, -apple-system, Arial, sans-serif;
      line-height:1.4;
    }
    header{
      position:sticky; top:0; z-index:5;
      background:linear-gradient(90deg,var(--brand),#a78bfa 50%, var(--brand-2));
      color:#fff; padding:16px 20px;
      display:flex; align-items:center; gap:12px;
      box-shadow:0 8px 24px rgba(124,58,237,.25);
    }
    header h1{font-size:20px; margin:0; letter-spacing:.3px}
    .badge{font-weight:700; background:rgba(255,255,255,.18); padding:6px 10px; border-radius:999px; font-size:12px}
    main{max-width:1100px; margin:24px auto; padding:0 16px 80px}
    .tabs{display:flex; gap:10px; margin-bottom:14px}
    .tabs button{
      border:0; padding:12px 20px; border-radius:999px; background:#f3e8ff; color:var(--ink); cursor:pointer; font-weight:800; font-size:15px;
      transition:all .2s ease;
    }
    .tabs button:hover{background:#e9d5ff; transform:scale(1.02)}
    .tabs button.active{background:var(--brand); color:#fff; box-shadow:0 4px 12px rgba(124,58,237,.3)}
    .card{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); padding:18px;
    }
    .grid-letters{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(64px,1fr)); gap:12px;
      margin-top:12px;
    }
    .btn-letter{
      aspect-ratio:1/1; border:0; border-radius:20px; background:linear-gradient(145deg,#faf5ff,#f3e8ff);
      font-size:42px; font-weight:900; color:var(--ink);
      cursor:pointer; box-shadow: 0 4px 12px rgba(124,58,237,.12), inset 0 0 0 3px #e9d5ff;
      transition:all .15s ease;
    }
    .btn-letter:hover{transform:translateY(-2px); box-shadow: 0 8px 20px rgba(124,58,237,.2), inset 0 0 0 3px var(--brand-3)}
    .btn-letter:active{transform:scale(.96)}
    .btn-letter[disabled]{opacity:.4; cursor:not-allowed; filter:grayscale(.6)}
    .btn-letter.locked{opacity:.3; border-style:dashed;}
    .hud{
      display:grid; grid-template-columns:1fr auto; align-items:center; gap:12px; margin:8px 0 14px;
    }
    .score{
      display:flex; gap:16px; font-weight:800; color:#1b2055;
    }
    .score .ok{color:var(--ok)} .score .bad{color:var(--bad)}
    .progress{
      height:10px; background:#eef0ff; border-radius:999px; overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.05);
    }
    .progress > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--brand),#7b84ff,#ff8a00); transition:width .3s ease}
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    .btn{
      border:0; padding:12px 18px; border-radius:14px; font-weight:800; cursor:pointer; font-size:15px;
      background:var(--brand); color:#fff; box-shadow:0 6px 18px rgba(124,58,237,.25);
      transition:all .2s ease;
    }
    .btn:hover{transform:translateY(-1px); box-shadow:0 8px 24px rgba(124,58,237,.35)}
    .btn:active{transform:translateY(0)}
    .btn.secondary{background:#f3e8ff; color:var(--brand)}
    .btn.secondary:hover{background:#e9d5ff}
    .btn.ghost{background:transparent; box-shadow:none; color:var(--brand)}
    .btn.danger{background:var(--bad)}
    .muted{color:var(--muted); font-size:14px}
    .hidden{display:none !important}

    /* Einstellungen */
    .settings-wrap{display:grid; grid-template-columns:1fr 370px; gap:16px}
    @media (max-width: 980px){ .settings-wrap{grid-template-columns:1fr} }
    .status-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(54px,1fr)); gap:10px}
    .status-tile{
      background:linear-gradient(145deg,#faf5ff,#f3e8ff);
      border-radius:16px; text-align:center; padding:12px 6px; position:relative; cursor:pointer; user-select:none;
      box-shadow: 0 2px 8px rgba(124,58,237,.1), inset 0 0 0 2px #e9d5ff;
      transition:all .15s ease;
      font-weight:900; font-size:28px; color:var(--ink);
    }
    .status-tile:hover{transform:translateY(-2px); box-shadow: 0 4px 12px rgba(124,58,237,.2), inset 0 0 0 2px var(--brand-3)}
    .status-tile:active{transform:scale(.98)}
    .status-dot{position:absolute; top:8px; right:8px; width:12px; height:12px; border-radius:999px; background:#d1d5db; box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}
    .status-diffs{
      display:flex;
      gap:4px;
      justify-content:center;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .status-pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:18px;
      height:18px;
      border-radius:12px;
      background:#ede9fe;
      color:#4c1d95;
      font-size:11px;
      font-weight:600;
      padding:0 5px;
      opacity:.35;
    }
    .status-pill.filled{
      opacity:1;
      background:#c4b5fd;
      color:#2e1065;
    }
    .status-tile.has{box-shadow: 0 2px 8px rgba(34,197,94,.15), inset 0 0 0 3px #86efac}
    .status-tile.has .status-dot{background:var(--ok); box-shadow:0 0 8px rgba(34,197,94,.4)}
    .lernweg-track{
      margin:16px 0 20px;
      padding:16px;
      border-radius:18px;
      background:linear-gradient(135deg,#f5f3ff,#ede9ff);
      border:2px solid #e9d5ff;
      box-shadow:0 8px 20px rgba(124,58,237,.12);
    }
    .lernweg-track .lernweg-head{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-weight:700;
      color:#4c1d95;
      margin-bottom:10px;
    }
    .lernweg-track .detail{font-size:13px; color:#6b7896; font-weight:600;}
    .lernweg-bar{
      position:relative;
      height:12px;
      border-radius:999px;
      background:#e0defb;
      overflow:hidden;
    }
    .lernweg-bar span{
      position:absolute;
      top:0; left:0;
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg,#7c3aed,#fb923c);
      box-shadow:0 6px 14px rgba(124,58,237,.3);
      transition:width .35s ease;
    }
    .lernweg-foot{margin-top:10px; font-size:13px;}
    .recorder{
      position:sticky; top:86px; align-self:start; background:linear-gradient(145deg,#faf5ff,var(--surface));
      border-radius:var(--radius); box-shadow:var(--shadow); padding:18px;
      border:2px solid #f3e8ff;
    }
    .mode-section{
      margin:24px 0 32px;
      padding:24px;
      background:linear-gradient(145deg,#faf5ff,var(--surface));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      display:grid;
      gap:20px;
    }
    .mode-section h2{margin:0; font-size:24px; color:var(--ink);}
    .mode-cards{display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:16px;}
    .mode-card{
      border:0;
      border-radius:24px;
      padding:18px;
      text-align:left;
      background:linear-gradient(160deg,#fff,#f3e8ff);
      box-shadow:0 10px 24px rgba(124,58,237,.18);
      color:var(--ink);
      font-weight:700;
      cursor:pointer;
      transition:transform .15s ease, box-shadow .15s ease;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .mode-card span{font-size:14px; color:#6b7896; font-weight:600;}
    .mode-card strong{font-size:18px; display:block; font-weight:800;}
    .mode-card:hover{transform:translateY(-2px); box-shadow:0 16px 30px rgba(124,58,237,.25);}
    .mode-card:active{transform:scale(.98);}
    .mode-card.active{outline:3px solid var(--brand); box-shadow:0 18px 30px rgba(124,58,237,.35);}
    .mode-controls{display:grid; gap:18px; padding:18px; border-radius:18px; background:#fff; box-shadow:0 6px 18px rgba(15,23,42,.12);}
    .mode-controls h3{margin:0 0 8px; font-size:18px; color:var(--ink);}
    .chip-group{display:flex; gap:8px; flex-wrap:wrap;}
    .chip{
      border:0;
      padding:10px 16px;
      border-radius:999px;
      background:#f3e8ff;
      color:var(--brand);
      font-weight:700;
      cursor:pointer;
      transition:transform .15s ease, box-shadow .15s ease;
    }
    .chip:hover{transform:translateY(-1px); box-shadow:0 8px 16px rgba(124,58,237,.2);}
    .chip.active{background:var(--brand); color:#fff; box-shadow:0 12px 20px rgba(124,58,237,.3);}
    .mode-warning{padding:12px 16px; border-radius:14px; background:rgba(251,191,36,.15); color:#92400e; font-weight:600; display:flex; gap:10px; align-items:center;}
    .mode-warning button{margin-left:auto; border:0; background:#f59e0b; color:#fff; padding:8px 14px; border-radius:999px; font-weight:700; cursor:pointer; box-shadow:0 10px 16px rgba(234,179,8,.3);}
    @media (max-width: 720px){
      .mode-section{padding:18px;}
      .mode-card{padding:16px;}
      .mode-controls{padding:14px;}
    }
    .mode-dialog .dialog{max-width:480px; text-align:center; padding:28px;}
    .mode-dialog h3{margin-top:0; font-size:24px; color:var(--ink);}
    .mode-dialog-cards{display:grid; gap:12px; margin:18px 0;}
    .mode-dialog-card{border:0; border-radius:20px; padding:18px; background:#fff; box-shadow:0 10px 20px rgba(15,23,42,.15);
      font-size:16px; font-weight:700; color:var(--ink); display:flex; flex-direction:column; gap:6px; cursor:pointer;
      transition:transform .15s ease, box-shadow .15s ease;
    }
    .mode-dialog-card strong{font-size:20px;}
    .mode-dialog-card span{font-size:14px; font-weight:600; color:#6b7896;}
    .mode-dialog-card:hover{transform:translateY(-2px); box-shadow:0 16px 30px rgba(124,58,237,.2);}
    .mode-dialog-card:active{transform:scale(.98);}
    .mode-dialog-card.active{outline:3px solid var(--brand); box-shadow:0 16px 36px rgba(124,58,237,.3);}
    .mode-dialog-actions{display:flex; gap:12px; justify-content:center; margin-top:18px; flex-wrap:wrap;}
    .individual-panel{
      margin-top:16px;
      padding:16px;
      background:linear-gradient(165deg,#ffffff,#f7f2ff);
      border-radius:18px;
      box-shadow:0 8px 20px rgba(124,58,237,.12);
      border:1px solid #e9d5ff;
    }
    .individual-panel .panel-label{display:block; font-weight:700; color:#4c1d95; margin:14px 0 6px; font-size:13px; text-transform:uppercase; letter-spacing:.02em;}
    .individual-panel .chip-group{margin-bottom:6px;}
    .recorder h3{margin:0 0 10px; color:var(--ink)}
    .rec-letter{
      font-size:64px; font-weight:900; display:inline-flex; align-items:center; justify-content:center;
      width:92px; height:92px; border-radius:20px;
      background:linear-gradient(145deg,#fff,#f3e8ff);
      box-shadow: 0 4px 16px rgba(124,58,237,.15), inset 0 0 0 3px #e9d5ff;
    }
    .clip-list{max-height:220px; overflow:auto; padding-right:4px;}
    .clip-item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 10px;
      border-radius:12px;
      background:#f5f3ff;
      border:1px solid #e0d5ff;
      transition:box-shadow .2s ease, transform .15s ease;
    }
    .clip-item.active{
      background:#fff;
      box-shadow:0 0 0 2px var(--brand-3);
      transform:translateY(-1px);
    }
    .clip-info{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .clip-badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background:#ede9fe;
      color:#4c1d95;
      font-size:12px;
      font-weight:700;
      border-radius:999px;
      padding:2px 8px;
    }
    .clip-meta{font-size:11px; color:#6b7896;}
    .clip-actions{display:flex; gap:6px; align-items:center;}
    .clip-actions .btn{min-width:36px; padding:4px 6px; font-size:14px;}
    .timer{font-variant-numeric:tabular-nums; font-weight:700}
    .blink{animation:blink 1s steps(1) infinite}
    @keyframes blink{50%{opacity:.35}}

    /* Overlays (Regenbogen, Monster, Pokal) */
    .overlay{
      position:fixed; inset:0; display:grid; place-items:center; background:rgba(255,255,255,.0);
      pointer-events:none; z-index:50;
    }
    .overlay .panel{
      display:grid; gap:12px; place-items:center;
      padding:12px; border-radius:20px;
      text-align:center; font-weight:900; font-size:20px; color:#1b2055;
      text-shadow:0 2px 0 #fff;
    }
    .unlock-banner{
      position:fixed;
      top:24px;
      left:50%;
      transform:translate(-50%,-10px);
      background:var(--brand);
      color:#fff;
      padding:16px 24px;
      border-radius:999px;
      box-shadow:0 18px 40px rgba(124,58,237,.35);
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:600;
      z-index:1000;
      opacity:0;
      transition:opacity .3s ease, transform .3s ease;
    }
    .unlock-banner.visible{
      opacity:1;
      transform:translate(-50%,0);
    }
    .unlock-banner strong{
      display:block;
      font-size:16px;
    }
    .unlock-banner span{
      font-size:14px;
      font-weight:500;
      line-height:1.3;
    }
    .tag{font-size:12px; font-weight:800; padding:4px 8px; border-radius:999px; background:rgba(0,0,0,.06)}
    .tada{animation:tada .8s ease both}
    @keyframes tada{
      0%{transform:scale(.8) rotate(-8deg)}
      50%{transform:scale(1.06) rotate(6deg)}
      100%{transform:scale(1) rotate(0)}
    }

    /* Buchstaben-Animation beim Klick */
    .letter-bounce{animation:letterBounce .5s ease both}
    @keyframes letterBounce{
      0%{transform:scale(1)}
      25%{transform:scale(1.15) rotate(-5deg)}
      50%{transform:scale(.95) rotate(5deg)}
      75%{transform:scale(1.05) rotate(-2deg)}
      100%{transform:scale(1) rotate(0)}
    }

    /* Puls-Animation f√ºr Buchstaben bei Spielstart */
    .letter-pulse{animation:letterPulse 1.2s ease-in-out infinite}
    @keyframes letterPulse{
      0%, 100%{transform:scale(1); opacity:1}
      50%{transform:scale(1.05); opacity:.85}
    }

    /* Regenbogen Zeichnen */
    .rainbow svg path{
      stroke-linecap:round;
      stroke-dasharray:1; stroke-dashoffset:1;
      animation:draw 900ms ease forwards;
    }
    .rainbow svg path:nth-child(1){animation-delay:0ms}
    .rainbow svg path:nth-child(2){animation-delay:60ms}
    .rainbow svg path:nth-child(3){animation-delay:120ms}
    .rainbow svg path:nth-child(4){animation-delay:180ms}
    .rainbow svg path:nth-child(5){animation-delay:240ms}
    .rainbow svg path:nth-child(6){animation-delay:300ms}
    @keyframes draw { to { stroke-dashoffset:0 } }

    /* Monster Wackeln */
    .monster svg .wiggle{animation:wiggle 680ms ease-in-out infinite}
    .monster svg .blink-eye{transform-origin:center; animation:blinkEye 3.2s infinite}
    @keyframes wiggle{
      0%{transform:rotate(-2deg) translateY(0)}
      50%{transform:rotate(2deg) translateY(-2px)}
      100%{transform:rotate(-2deg) translateY(0)}
    }
    @keyframes blinkEye{
      0%,10%,100%{transform:scaleY(1)}
      11%,12%{transform:scaleY(.1)}
      13%,100%{transform:scaleY(1)}
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:grid; place-items:center; z-index:60; background:rgba(0,0,0,.25)}
    .dialog{background:#fff; border-radius:24px; box-shadow:var(--shadow);
      width:min(560px,92vw); padding:20px; text-align:center}
    .dialog h3{margin:.4rem 0}
    .trophy{display:block; margin:6px auto 12px; width:160px; height:auto}
    .result-line{font-weight:900; font-size:18px}

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      .rainbow svg path,.tada,.monster svg .wiggle{animation:none !important}
    }

    /* Empty State Info Box */
    .info-box{
      background:linear-gradient(135deg,#fef3c7,#fef9e7);
      border:3px solid var(--brand-2);
      border-radius:var(--radius);
      padding:24px;
      margin-bottom:16px;
      text-align:center;
      box-shadow:0 6px 20px rgba(251,146,60,.15);
    }
    .info-box h3{margin:0 0 10px; color:var(--ink); font-size:20px}
    .info-box p{margin:10px 0; color:var(--muted); line-height:1.6; font-size:15px}
    .info-box .btn{margin-top:12px}
    .progress-badge{
      display:inline-block;
      background:linear-gradient(135deg,var(--brand),#a78bfa);
      color:#fff;
      padding:10px 20px;
      border-radius:999px;
      font-weight:900;
      font-size:17px;
      margin-bottom:14px;
      box-shadow:0 6px 16px rgba(124,58,237,.3);
    }
    .progress-badge.empty{background:#f3e8ff; color:var(--brand); border:2px solid #e9d5ff}

    footer{max-width:1100px; margin:-52px auto 32px; padding:0 16px; color:#6b7280; font-size:13px}

    /* Set-Karten */
    .set-card{
      background:linear-gradient(145deg,#fff,#f3e8ff);
      border-radius:16px; padding:14px 18px; min-width:200px;
      box-shadow:0 4px 12px rgba(124,58,237,.15), inset 0 0 0 2px #e9d5ff;
      cursor:pointer; transition:all .2s ease; position:relative;
    }
    .set-card:hover{transform:translateY(-2px); box-shadow:0 6px 18px rgba(124,58,237,.25), inset 0 0 0 2px var(--brand)}
    .set-card.active{background:linear-gradient(145deg,var(--brand),#a78bfa); color:#fff; box-shadow:0 6px 18px rgba(124,58,237,.35), inset 0 0 0 3px rgba(255,255,255,.2)}
    .set-card.active .set-emoji{text-shadow:0 2px 4px rgba(0,0,0,.2)}
    .set-card.active .set-name{font-weight:900}
    .set-card.active .set-count{color:rgba(255,255,255,.9)}
    .set-emoji{font-size:32px; margin-bottom:6px; display:block}
    .set-name{font-weight:800; font-size:16px; margin-bottom:4px}
    .set-count{font-size:13px; color:var(--muted); font-weight:600}
    .set-actions{position:absolute; top:10px; right:10px; display:flex; gap:4px; opacity:0; transition:opacity .2s}
    .set-card:hover .set-actions{opacity:1}
    .set-btn{border:0; background:rgba(255,255,255,.9); width:28px; height:28px; border-radius:50%; cursor:pointer; font-size:14px; display:grid; place-items:center; transition:all .15s}
    .set-btn:hover{transform:scale(1.1); background:#fff}
    .set-card.active .set-btn{background:rgba(255,255,255,.25); color:#fff}
    .set-card.active .set-btn:hover{background:rgba(255,255,255,.4)}

    /* Sticker-Album */
    .sticker-slot{
      aspect-ratio:1; border-radius:12px; background:linear-gradient(145deg,#faf5ff,#f3e8ff);
      display:grid; place-items:center; font-size:48px; cursor:pointer;
      box-shadow:0 2px 8px rgba(124,58,237,.1), inset 0 0 0 2px #e9d5ff;
      transition:all .2s; position:relative;
    }
    .sticker-slot:hover{transform:translateY(-2px); box-shadow:0 4px 12px rgba(124,58,237,.2)}
    .sticker-slot.locked{opacity:.3; background:#f0f0f0; cursor:default}
    .sticker-slot.locked:hover{transform:none}
    .sticker-slot.collected{animation:popIn .3s ease}
    @keyframes popIn{ 0%{transform:scale(.8)} 50%{transform:scale(1.1)} 100%{transform:scale(1)} }
    .album-grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(80px,1fr)); gap:12px}

    /* Install Button */
    .install-btn{
      display:none; border:0; padding:8px 14px; border-radius:999px;
      background:rgba(255,255,255,.22); color:#fff; font-weight:700; font-size:13px;
      cursor:pointer; transition:background .2s ease; white-space:nowrap;
    }
    .install-btn:hover{background:rgba(255,255,255,.32)}
    .install-btn.show{display:block}

    /* Settings Button (Zahnrad) */
    .settings-btn{
      border:0; padding:10px; border-radius:50%; width:42px; height:42px;
      background:rgba(255,255,255,.22); color:#fff; font-size:20px;
      cursor:pointer; transition:all .2s ease; display:grid; place-items:center;
      margin-left:auto;
    }
    .settings-btn:hover{background:rgba(255,255,255,.32); transform:rotate(30deg)}
    /* Statistik-Bereich */
    .challenge-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }
    .challenge-card {
      background: #fff9f9;
      border: 2px solid var(--bad);
      border-radius: var(--radius);
      padding: 16px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.1);
    }
    .challenge-letter {
      font-size: 48px;
      font-weight: 900;
      color: var(--bad);
    }
    .challenge-count {
      font-weight: 700;
      color: #b91c1c;
    }
    .challenge-confusion {
      font-size: 14px;
      color: var(--muted);
      margin-top: 8px;
      min-height: 20px;
    }
    .super-letter-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .super-letter-tile {
      background: #f0fff4;
      border: 2px solid var(--ok);
      color: #166534;
      font-weight: 800;
      font-size: 24px;
      border-radius: 16px;
      width: 54px;
      height: 54px;
      display: grid;
      place-items: center;
    }
  </style>
</head>
<body>
  <header>
    <h1>ABC‚ÄëAbenteuer ¬∑ H√∂r &amp; Finde</h1>
    <span class="badge">Prototyp</span>
    <button id="installBtn" class="install-btn">üì± Installieren</button>
    <button id="settingsBtn" class="settings-btn" title="Einstellungen">‚öôÔ∏è</button>
  </header>

  <main>
    <nav class="tabs">
      <button class="active" data-tab="spiel">Spiel</button>
      <button data-tab="ueben">√úben</button>
      <button data-tab="album">üéÅ Mein Album</button>
      <button data-tab="eltern">üë®‚Äçüë©‚Äçüëß F√ºr Eltern</button>
    </nav>

    <!-- SPIEL -->
    <section id="spiel" class="card">
      <div id="setup">
        <!-- Info-Box bei fehlenden Aufnahmen -->
        <div id="emptyState" class="info-box hidden">
          <h3>üéôÔ∏è Noch keine Aufnahmen vorhanden</h3>
          <p>Um das Spiel zu starten, musst du zuerst deine Stimme f√ºr mindestens einen Buchstaben aufnehmen.</p>
          <button id="goToSettings" class="btn">Jetzt Aufnahmen machen</button>
        </div>

        <p class="muted">W√§hle das Set, die Rundenzahl und starte. Das Spiel nutzt nur Buchstaben, f√ºr die <b>bereits Aufnahmen</b> vorhanden sind.</p>

        <div id="lernwegTrack" class="lernweg-track hidden" role="group" aria-label="Lernweg-Fortschritt">
          <div class="lernweg-head">
            <span>Lernweg-Fortschritt</span>
            <span id="lernwegDetail" class="detail"></span>
          </div>
          <div class="lernweg-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
            <span id="lernwegFill"></span>
          </div>
          <div id="lernwegNext" class="lernweg-foot muted"></div>
        </div>

        <div style="margin:16px 0">
          <label style="font-weight:800; display:block; margin-bottom:8px">üé§ Welche Aufnahmen?</label>
          <select id="setSelector" class="btn secondary" style="width:100%; max-width:300px; text-align:left; font-size:16px; padding:12px">
            <option value="">Lade...</option>
          </select>
        </div>

        <div class="controls" style="margin:10px 0 6px">
          <label>Runden:
            <input id="rounds" type="range" min="5" max="26" value="10" step="1" style="vertical-align:middle">
            <b><span id="roundsOut">10</span></b>
          </label>
          <button id="btnStart" class="btn">Spiel starten</button>
          <button id="btnChangeMode" class="btn secondary" type="button">Modus wechseln</button>
        </div>
        <p id="modeHint" class="muted hidden" style="margin-top:-6px"></p>
      </div>

      <div id="hud" class="hud hidden">
        <div class="score">
          <span>Runde <b id="roundNow">1</b>/<b id="roundMax">10</b></span>
          <span class="ok">Richtig: <b id="okCount">0</b></span>
          <span class="bad">Falsch: <b id="badCount">0</b></span>
        </div>
        <div class="progress"><i id="bar"></i></div>
        <div class="in-game-controls" style="margin-top:10px; display:flex; gap:12px; align-items:center;">
          <button id="btnTestAudio" class="btn secondary" title="Aktuellen Buchstaben nochmals anh√∂ren" disabled>üîä Nochmal anh√∂ren</button>
          <div style="margin-left:auto">
            <label style="font-weight:600; font-size:13px; color:var(--muted)">Audio:</label>
            <select id="inGameDifficulty" class="btn secondary" style="padding: 8px 12px; font-size:14px;">
              <option value="LEICHT">Leicht</option>
              <option value="MITTEL">Mittel</option>
              <option value="SCHWER">Schwer</option>
              <option value="AFFIG">Affig</option>
            </select>
          </div>
        </div>
      </div>

      <div id="letters" class="grid-letters" aria-label="Buchstaben-Auswahl"></div>
    </section>

    <!-- MEIN ALBUM -->
    <section id="album" class="card hidden">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px">
        <h2 style="margin:0">üéÅ Mein Sticker-Album</h2>
        <div style="font-weight:800; font-size:18px">‚≠ê <span id="starCount">0</span> Sterne</div>
      </div>

      <div id="albumTabs" style="display:flex; gap:8px; margin-bottom:16px; overflow-x:auto"></div>
      <div id="albumContent"></div>

      <div style="margin-top:20px; text-align:center">
        <button id="btnOpenPack" class="btn" disabled>üéÅ Pack √∂ffnen (10 ‚≠ê)</button>
      </div>
    </section>

    <!-- √úBEN -->
    <section id="ueben" class="card hidden">
      <h2>√úbungsmodus</h2>
      <p class="muted">W√§hle eine Schwierigkeit und klicke auf einen Buchstaben, um die Aufnahme anzuh√∂ren.</p>
      <div class="controls" style="margin:10px 0 14px">
        <label style="font-weight:600; font-size:13px; color:var(--muted)">Schwierigkeit:</label>
        <select id="practiceDifficulty" class="btn secondary" style="padding: 8px 12px; font-size:14px;">
          <option value="LEICHT">Leicht</option>
          <option value="MITTEL">Mittel</option>
          <option value="SCHWER">Schwer</option>
          <option value="AFFIG">Affig</option>
        </select>
      </div>
      <div id="practiceLetters" class="grid-letters" aria-label="Buchstaben-Auswahl"></div>
    </section>

    <!-- ELTERN-BEREICH -->
    <section id="eltern" class="card hidden">
      <h2>Statistiken & Fortschritt</h2>
      <p class="muted">Hier sehen Sie bald eine Auswertung des Lernfortschritts.</p>
    </section>

    <!-- EINSTELLUNGEN -->
    <section id="einstellungen" class="card hidden">
      <!-- Set-Verwaltung -->
      <div style="margin-bottom:24px; padding-bottom:24px; border-bottom:2px solid #f3e8ff">
        <p><b>Aufnahme-Sets verwalten</b></p>
        <p class="muted">Erstelle verschiedene Aufnahme-Sets (z.B. "Mit W√∂rtern", "Nur Buchstaben", "Kinderstimme") und wechsle zwischen ihnen.</p>

        <div id="setsList" style="display:flex; gap:10px; flex-wrap:wrap; margin:16px 0"></div>

        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; align-items:center">
          <button id="btnCreateSet" class="btn secondary">‚ûï Neues Set erstellen</button>
          <div style="margin-left:auto; display:flex; gap:8px; align-items:center">
            <label style="font-weight:600; color:#6b7896">Standard-Set:</label>
            <select id="defaultSetSelector" class="btn secondary" style="min-width:200px; text-align:left; font-size:14px"></select>
          </div>
        </div>
      </div>

      <div class="info-box" style="margin-bottom:24px;">
        <h3 style="margin-top:0">Spielmodus &amp; Audio-Stil</h3>
        <p class="muted">Den Modus (Anf√§nger, Lernweg, Meister) und den Audio-Stil (Auto, Buchstabe + Anlaut, ‚Ä¶) w√§hlst du jetzt direkt beim Spielstart.</p>
        <button id="btnParentModeDialog" class="btn secondary" type="button">Modusauswahl anzeigen</button>
      </div>

      <div class="settings-wrap">
        <div>
          <p><b>Einstellungen ¬∑ Aufnahmen</b></p>
          <div id="progressBadge" class="progress-badge empty">0 von 26 Buchstaben aufgenommen</div>
          <p class="muted">Tippe einen Buchstaben an, um ihn aufzunehmen. Deine Aufnahmen werden <b>nur lokal</b> gespeichert.</p>
          <div id="statusGrid" class="status-grid" aria-label="Aufnahmestatus"></div>
          <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center">
            <button id="exportBtn" class="btn secondary">üì¶ Exportieren</button>
            <button id="importBtn" class="btn secondary">üì• Importieren</button>
            <input type="file" id="importFile" accept=".zip" style="display:none">
            <button id="clearAll" class="btn danger">Alle l√∂schen</button>
            <span class="muted">Mikrofon ben√∂tigt https/localhost.</span>
          </div>
        </div>

        <aside class="recorder">
          <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px">
            <div id="recLetter" class="rec-letter">A</div>
            <div>
              <h3 style="margin:.2rem 0">Aufnahme: <span id="recTitle">A</span></h3>
              <div class="muted">Status: <b id="recStatus">Keine Aufnahme</b></div>
            </div>
          </div>
          <div id="recordDifficultyGroup" class="chip-group" style="margin-bottom:8px; display:flex; gap:8px; flex-wrap:wrap">
            <button type="button" class="chip active" data-record-difficulty="LEICHT">Leicht</button>
            <button type="button" class="chip" data-record-difficulty="MITTEL">Mittel</button>
            <button type="button" class="chip" data-record-difficulty="SCHWER">Schwer</button>
            <button type="button" class="chip" data-record-difficulty="AFFIG">Affig</button>
          </div>
          <div class="controls" style="margin:10px 0">
            <button id="btnRec" class="btn">üéôÔ∏è Aufnehmen</button>
            <button id="btnPlay" class="btn secondary" disabled>‚ñ∂Ô∏è Testen</button>
            <button id="btnDelete" class="btn ghost" disabled>üóëÔ∏è L√∂schen</button>
            <span class="timer" id="timer">00:00</span>
          </div>
          <div id="clipList" class="clip-list" style="display:flex; flex-direction:column; gap:6px; margin-bottom:8px"></div>
          <div class="muted">Tipp: Spreche klar und kurz (z.‚ÄØB. ‚ÄûB‚Äú oder ‚ÄûB ‚Äì wie Ball‚Äú).</div>
        </aside>
      </div>
  </section>
</main>

  <div id="unlockBanner" class="unlock-banner hidden" role="status" aria-live="polite">
    <span aria-hidden="true">üéâ</span>
    <span>
      <strong>N√§chste Stufe freigeschaltet!</strong>
      <span id="unlockBannerText">Weiter geht's!</span>
    </span>
  </div>

  <!-- Overlays: Regenbogen / Monster -->
  <div id="overlayGood" class="overlay hidden" role="alert" aria-live="assertive">
    <div class="panel rainbow tada">
      <!-- Regenbogen SVG -->
      <svg viewBox="0 0 600 320" width="320" height="170" aria-hidden="true">
        <path d="M60,280 A240,240 0 0 1 540,280" stroke="#ff3b30" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M90,280 A210,210 0 0 1 510,280" stroke="#ff9500" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M120,280 A180,180 0 0 1 480,280" stroke="#ffcc00" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M150,280 A150,150 0 0 1 450,280" stroke="#34c759" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M180,280 A120,120 0 0 1 420,280" stroke="#0bb1ff" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M210,280 A90,90 0 0 1 390,280" stroke="#af52de" stroke-width="26" fill="none" pathLength="1"></path>
      </svg>
      <div class="tag">Super! üéâ</div>
    </div>
  </div>

  <div id="overlayBad" class="overlay hidden" role="alert" aria-live="assertive">
    <div class="panel monster">
      <!-- ‚ÄûGeneriertes" Monster als Inline‚ÄëSVG -->
      <svg viewBox="0 0 300 300" width="240" height="240" aria-label="Monster">
        <defs>
          <filter id="shadow"><feDropShadow dx="0" dy="3" stdDeviation="4" flood-color="#000" flood-opacity=".25"/></filter>
        </defs>
        <!-- K√∂rper -->
        <g class="wiggle" filter="url(#shadow)">
          <ellipse cx="150" cy="170" rx="100" ry="110" fill="#7b5cff"/>
          <!-- H√∂rner -->
          <path d="M85,85 L105,30 L125,85" fill="#ff8a00"/>
          <path d="M175,85 L195,30 L215,85" fill="#ff8a00"/>
          <!-- Augen -->
          <circle cx="115" cy="140" r="26" fill="#fff"/>
          <circle cx="185" cy="140" r="26" fill="#fff"/>
          <circle class="blink-eye" cx="115" cy="140" r="11" fill="#111"/>
          <circle class="blink-eye" cx="185" cy="140" r="11" fill="#111"/>
          <!-- Mund -->
          <rect x="105" y="190" width="90" height="30" rx="14" fill="#111"/>
          <!-- Z√§hne -->
          <polygon points="115,190 125,210 135,190" fill="#fff"/>
          <polygon points="145,190 155,210 165,190" fill="#fff"/>
          <polygon points="175,190 185,210 195,190" fill="#fff"/>
          <!-- F√º√üe -->
          <ellipse cx="110" cy="260" rx="26" ry="10" fill="#6a52ff"/>
          <ellipse cx="190" cy="260" rx="26" ry="10" fill="#6a52ff"/>
        </g>
      </svg>
      <div class="tag">Fast! Versuch's nochmal üëª</div>
      <div style="background:#fff; border-radius:20px; padding:20px; margin-top:16px; box-shadow:0 8px 24px rgba(0,0,0,.15);">
        <div style="font-size:18px; color:#6b7896; margin-bottom:8px;">Das war:</div>
        <div id="correctLetter" style="font-size:72px; font-weight:900; color:var(--brand); text-shadow:0 3px 8px rgba(124,58,237,.3);">A</div>
      </div>
      <div style="margin-top:16px; font-size:14px; color:#6b7896; opacity:.8;">üëÜ Tippe zum Weitermachen</div>
    </div>
  </div>

  <!-- Ergebnis-Modal -->
  <div id="modal" class="modal hidden" aria-modal="true" role="dialog">
    <div class="dialog">
      <svg class="trophy" viewBox="0 0 200 200" aria-hidden="true">
        <!-- Einfacher Pokal -->
        <g id="cup">
          <rect x="80" y="130" width="40" height="20" fill="#a8875a"/>
          <rect x="60" y="150" width="80" height="12" fill="#6b5438"/>
          <path d="M70,55 h60 v50 a30,22 0 0 1 -60,0 z" fill="#d6b36a" stroke="#a8875a" stroke-width="3"/>
          <path d="M70,55 h60 v8 h-60 z" fill="#e8c675"/>
          <path d="M70,105 a30,22 0 0 0 60,0" fill="none" stroke="#855e2e" stroke-width="3" opacity=".35"/>
          <!-- Henkel -->
          <path d="M130,65 c25,0 30,30 5,38" stroke="#a8875a" stroke-width="6" fill="none"/>
          <path d="M70,65 c-25,0 -30,30 -5,38" stroke="#a8875a" stroke-width="6" fill="none"/>
          <!-- Stern -->
          <polygon id="star" points="100,82 106,94 120,96 110,105 112,118 100,112 88,118 90,105 80,96 94,94" fill="#fff176" stroke="#d6b36a"/>
        </g>
      </svg>
      <h3 id="resultTitle">Toll gemacht!</h3>
      <p class="result-line"><span id="resultText">8 von 10 richtig</span></p>
      <div class="controls" style="justify-content:center; margin-top:10px">
        <button id="again" class="btn">Nochmal spielen</button>
        <button id="closeModal" class="btn secondary">Schlie√üen</button>
      </div>
    </div>
  </div>

  <div id="modeDialog" class="modal hidden mode-dialog" role="dialog" aria-modal="true" aria-labelledby="modeDialogTitle">
    <div class="dialog">
      <h3 id="modeDialogTitle">Wie m√∂chtest du spielen?</h3>
      <p class="muted" style="margin:0 0 12px">Tippe eine Karte, dann geht es los!</p>
      <div class="mode-dialog-cards" role="group" aria-label="Moduswahl">
        <button type="button" class="mode-dialog-card" data-mode-option data-mode="LERNWEG">
          <strong>ü¶ã Lernweg</strong>
          <span>Gef√ºhrter Pfad mit Belohnungen</span>
        </button>
        <button type="button" class="mode-dialog-card" data-mode-option data-mode="FREI">
          <strong>üé® Individuelles Spiel</strong>
          <span>Stelle dein eigenes Spiel zusammen</span>
        </button>
      </div>
      <div class="mode-dialog-actions">
        <button id="modeDialogCancel" class="btn secondary" type="button">Zur√ºck</button>
        <button id="modeDialogStart" class="btn" type="button" disabled>Los geht's!</button>
      </div>
      <div id="individualPanel" class="individual-panel hidden">
        <p class="muted" style="margin-top:0">Stelle dein Spiel selbst zusammen.</p>
        <span class="panel-label">Buchstaben-Anzahl</span>
        <div class="chip-group" id="freeCountGroup" role="group" aria-label="Anzahl Buchstaben">
          <button type="button" class="chip" data-free-count="4">4 Buchstaben</button>
          <button type="button" class="chip" data-free-count="8">8 Buchstaben</button>
          <button type="button" class="chip" data-free-count="12">12 Buchstaben</button>
          <button type="button" class="chip" data-free-count="26">Alle 26</button>
        </div>
        <span class="panel-label">Audio-Schwierigkeit</span>
        <div class="chip-group" id="difficultyGroup" role="group" aria-label="Schwierigkeit ausw√§hlen">
            <button type="button" class="chip" data-difficulty="LEICHT">üòä Leicht</button>
            <button type="button" class="chip" data-difficulty="MITTEL">üòê Mittel</button>
            <button type="button" class="chip" data-difficulty="SCHWER">üò¨ Schwer</button>
            <button type="button" class="chip" data-difficulty="AFFIG">ü§™ Affig</button>
        </div>
      </div>
    </div>
  </div>

  <div id="parentalGate" class="modal hidden" role="dialog" aria-modal="true">
    <div class="dialog">
      <h3>Bitte best√§tigen</h3>
      <p class="muted">Um fortzufahren, beantworten Sie bitte diese Frage:</p>
      <p id="gateQuestion" style="font-size: 20px; font-weight: bold; margin: 16px 0;"></p>
      <input type="number" id="gateAnswer" style="padding: 12px; font-size: 18px; text-align: center; border-radius: 12px; border: 2px solid #ddd; width: 100px;">
      <div class="controls" style="justify-content:center; margin-top:20px">
          <button id="gateCancel" class="btn secondary">Abbrechen</button>
          <button id="gateSubmit" class="btn">Best√§tigen</button>
      </div>
    </div>
  </div>

  <footer>
    <p>Made for kids üíú ¬∑ Alle Daten bleiben auf diesem Ger√§t. | <span class="muted">Bei iOS/Safari evtl. ‚ÄûMikrofon erlauben‚Äú best√§tigen.</span></p>
  </footer>

      <script type="module">
            import {
        getProgress,
        saveProgress,
        markCorrect,
        markWrong
      } from './app/progressStore.js';
      import { pickNext } from './app/letterPool.js';
      import { advanceAfterRun } from './app/progression.js';
  
  
    // Persisted Lernfortschritt wird sofort initialisiert
      getProgress();
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // ABC-Abenteuer ‚Äì Logik
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Soundeffekte (Web Audio API)
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    let unlockBannerTimer = null;

    function initAudioContext(){
      if(!audioCtx) audioCtx = new AudioContext();
      return audioCtx;
    }

    // Erfolgs-Sound: Fr√∂hlicher aufsteigender Ton
    function playSuccessSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
      osc.frequency.exponentialRampToValueAtTime(783.99, ctx.currentTime + 0.1); // G5
      osc.frequency.exponentialRampToValueAtTime(1046.50, ctx.currentTime + 0.2); // C6

      gain.gain.setValueAtTime(0.3, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.4);
    }

    // Fehler-Sound: Sanfter absteigender Ton
    function playErrorSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'triangle';
      osc.frequency.setValueAtTime(329.63, ctx.currentTime); // E4
      osc.frequency.exponentialRampToValueAtTime(246.94, ctx.currentTime + 0.15); // B3

      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.3);
    }

    // Klick-Sound: Kurzer Feedback-Ton beim Buchstaben-Klick
    function playClickSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(880, ctx.currentTime); // A5

      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.08);
    }

    const LETTERS = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const elLetters = document.getElementById('letters');
    const elStatusGrid = document.getElementById('statusGrid');
    const elRecLetter = document.getElementById('recLetter');
    const elRecTitle = document.getElementById('recTitle');
    const elRecStatus = document.getElementById('recStatus');
    const elBtnRec = document.getElementById('btnRec');
    const elBtnPlay = document.getElementById('btnPlay');
    const elBtnDelete = document.getElementById('btnDelete');
    const elRecordDifficultyGroup = document.getElementById('recordDifficultyGroup');
    const elClipList = document.getElementById('clipList');
    const elLernwegTrack = document.getElementById('lernwegTrack');
    const elLernwegDetail = document.getElementById('lernwegDetail');
    const elLernwegFill = document.getElementById('lernwegFill');
    const elLernwegNext = document.getElementById('lernwegNext');
    const elTimer = document.getElementById('timer');
    const elRoundNow = document.getElementById('roundNow');
    const elUnlockBanner = document.getElementById('unlockBanner');
    const elUnlockBannerText = document.getElementById('unlockBannerText');
    const dialogModeCards = Array.from(document.querySelectorAll('[data-mode-option]'));
    const elModeDialog = document.getElementById('modeDialog');
    const elModeDialogStart = document.getElementById('modeDialogStart');
    const elModeDialogCancel = document.getElementById('modeDialogCancel');
    const elModeControls = document.getElementById('modeControls');
    const elFreeCountGroup = document.getElementById('freeCountGroup');
    const elDifficultyGroup = document.getElementById('difficultyGroup');
    const elDifficultyWrapper = document.getElementById('difficultyWrapper');
    const elIndividualPanel = document.getElementById('individualPanel');
    const elRoundMax = document.getElementById('roundMax');
    const elOk = document.getElementById('okCount');
    const elBad = document.getElementById('badCount');
    const elBar = document.getElementById('bar');
    const elHud = document.getElementById('hud');
    const elOverlayGood = document.getElementById('overlayGood');
    const elOverlayBad = document.getElementById('overlayBad');
    const elCorrectLetter = document.getElementById('correctLetter');
    const elModal = document.getElementById('modal');
    const elResultTitle = document.getElementById('resultTitle');
    const elResultText = document.getElementById('resultText');
    const elBtnStart = document.getElementById('btnStart');
    const elBtnChangeMode = document.getElementById('btnChangeMode');
    const elBtnParentModeDialog = document.getElementById('btnParentModeDialog');
    elBtnParentModeDialog.addEventListener('click', openModeDialog);
    const elModeHint = document.getElementById('modeHint');
    const elBtnTestAudio = document.getElementById('btnTestAudio');
    const elRounds = document.getElementById('rounds');
    const elRoundsOut = document.getElementById('roundsOut');
    elBtnChangeMode.addEventListener('click', openModeDialog);

    // Eltern-Sperre
    const elParentalGate = document.getElementById('parentalGate');
    const elGateQuestion = document.getElementById('gateQuestion');
    const elGateAnswer = document.getElementById('gateAnswer');
    const elGateCancel = document.getElementById('gateCancel');
    const elGateSubmit = document.getElementById('gateSubmit');
    let gateNum1, gateNum2;
    let isParentalGatePassed = false; // Simple session flag

    // Tabs & Parental Gate
    const tabsContainer = document.querySelector('.tabs');

    function openParentalGate() {
      gateNum1 = Math.floor(Math.random() * 5) + 5;
      gateNum2 = Math.floor(Math.random() * 5) + 1;
      elGateQuestion.textContent = `Was ist ${gateNum1} + ${gateNum2}?`;
      elGateAnswer.value = '';
      elParentalGate.classList.remove('hidden');
      elGateAnswer.focus();
    }

    function closeParentalGate() {
      elParentalGate.classList.add('hidden');
    }

    elGateCancel.addEventListener('click', closeParentalGate);
    elGateSubmit.addEventListener('click', () => {
      const answer = parseInt(elGateAnswer.value, 10);
      if (answer === gateNum1 + gateNum2) {
        isParentalGatePassed = true;
        closeParentalGate();
        switchToTab('eltern');
      } else {
        alert('Leider falsch. Bitte versuche es nochmal.');
        openParentalGate();
      }
    });

    function switchToTab(tabName) {
      tabsContainer.querySelectorAll('button').forEach(b => {
        const isActive = b.dataset.tab === tabName;
        b.classList.toggle('active', isActive);
      });
      document.getElementById('spiel').classList.toggle('hidden', tabName !== 'spiel');
      document.getElementById('ueben').classList.toggle('hidden', tabName !== 'ueben');
      document.getElementById('album').classList.toggle('hidden', tabName !== 'album');
      document.getElementById('einstellungen').classList.toggle('hidden', tabName !== 'einstellungen');
      document.getElementById('eltern').classList.toggle('hidden', tabName !== 'eltern');

      if (tabName === 'einstellungen') {
        renderSetsList();
        updateStatusGridFromDB();
        updateUIForRecordingState();
      }

      if (tabName === 'album') {
        renderAlbum();
      }

      if (tabName === 'eltern') {
        renderStatistics();
      }

      if (tabName === 'ueben') {
        renderPracticeGrid();
      }
    }

    tabsContainer.addEventListener('click', (e) => {
      const targetButton = e.target.closest('button');
      if (!targetButton) return;
      const tabName = targetButton.dataset.tab;

      if (tabName === 'eltern' && !isParentalGatePassed) {
        openParentalGate();
        return;
      }

      switchToTab(tabName);
    });

    function renderStatistics() {
      const elternSection = document.getElementById('eltern');
      const progress = getProgress();
      const log = progress.attemptLog || [];

      if (log.length < 10) { // Require a minimum amount of data
        elternSection.innerHTML = `
          <h2>Statistiken & Fortschritt</h2>
          <p class="muted">Es sind noch nicht gen√ºgend Daten vorhanden. Spielen Sie noch ein paar Runden, um eine aussagekr√§ftige Auswertung zu sehen.</p>
        `;
        return;
      }

      // Data processing
      const wrongAttempts = {}; // { B: 5, D: 3 }
      const confusions = {}; // { B: { P: 4, D: 1 } }
      const correctCounts = {}; // { A: 10, C: 12 }

      for (const attempt of log) {
        if (attempt.correct) {
          correctCounts[attempt.target] = (correctCounts[attempt.target] || 0) + 1;
        } else {
          if (!attempt.target || !attempt.chosen) continue; // Skip incomplete log entries
          wrongAttempts[attempt.target] = (wrongAttempts[attempt.target] || 0) + 1;
          if (!confusions[attempt.target]) {
            confusions[attempt.target] = {};
          }
          confusions[attempt.target][attempt.chosen] = (confusions[attempt.target][attempt.chosen] || 0) + 1;
        }
      }

      const sortedWrong = Object.entries(wrongAttempts).sort((a, b) => b[1] - a[1]);
      
      const superBuchstaben = Object.entries(correctCounts)
        .filter(([letter, count]) => count >= 5 && !wrongAttempts[letter])
        .map(([letter]) => letter)
        .sort();

      // HTML Rendering
      let html = '<h2>Statistiken & Fortschritt</h2>';

      // 1. N√§chste Herausforderung
      html += '<h3>N√§chste Herausforderungen</h3>';
      const topWrong = sortedWrong.slice(0, 3);

      if (topWrong.length > 0) {
        html += '<p class="muted">Dies sind die Buchstaben, die aktuell am h√§ufigsten verwechselt werden.</p>';
        html += '<div class="challenge-grid">';
        for (const [letter, count] of topWrong) {
          let confusionText = '';
          if (confusions[letter]) {
            const sortedConfusions = Object.entries(confusions[letter]).sort((a, b) => b[1] - a[1]);
            if (sortedConfusions.length > 0) {
              confusionText = `(wird oft mit <b>${sortedConfusions[0][0]}</b> verwechselt)`;
            }
          }
          html += `
            <div class="challenge-card">
              <div class="challenge-letter">${letter}</div>
              <div class="challenge-count">${count} mal falsch</div>
              <div class="challenge-confusion">${confusionText}</div>
            </div>
          `;
        }
        html += '</div>';
        const practiceLetters = topWrong.map(([l]) => l).join(',');
        html += `<div style="margin-top: 16px;"><button class="btn practice-btn" data-letters="${practiceLetters}">Diese ${topWrong.length} Buchstaben √ºben</button></div>`;
      } else {
        html += '<p class="muted">üéâ Super! Aktuell gibt es keine besonderen Herausforderungen.</p>';
      }

      // 2. Super-Buchstaben
      html += '<h3 style="margin-top: 24px;">Super-Buchstaben</h3>';
      if (superBuchstaben.length > 0) {
        html += `<p class="muted">Diese ${superBuchstaben.length} Buchstaben werden schon sehr gut erkannt.</p>';
        // html += "<div class='super-letter-grid'>";
        html += superBuchstaben.map(l => `<div class="super-letter-tile">${l}</div>`).join('');
        // html += '</div>';
      } else {
        html += '<p class="muted">Noch keine Super-Buchstaben. Aber das wird schon!</p>';
      }
      
      elternSection.innerHTML = html;

      // Add event listeners for the new buttons
      elternSection.querySelectorAll('.practice-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const letters = e.currentTarget.dataset.letters.split(',');
          startPracticeGame(letters);
        });
      });
    }

    dialogModeCards.forEach(card => {
      card.addEventListener('click', () => {
        if (!pendingModeSelection) {
          pendingModeSelection = extractSelectionFromProgress(getProgress());
        }
        const mode = card.dataset.mode || 'FREI';
        pendingModeSelection.mode = mode;

        // Automatically open the individual panel for custom games
        toggleIndividualPanel(mode === 'FREI');

        updateModeDialogCards(pendingModeSelection);
        elModeDialogStart.disabled = false;
      });
    });

    if(elModeDialogStart){
      elModeDialogStart.addEventListener('click', () => {
        if(!pendingModeSelection) return;

        const updates = { 
          mode: pendingModeSelection.mode, 
          difficulty: pendingModeSelection.difficulty || 'LEICHT',
        };

        if(pendingModeSelection.mode === 'FREI'){
          updates.freeLetterCount = pendingModeSelection.freeLetterCount || 4;
        } else {
          // Lernweg uses its own progression for letter count
        }
        
        saveAndApply(updates);
        closeModeDialog();
        startGame();
      });
    }

    if(elFreeCountGroup){
      elFreeCountGroup.addEventListener('click', (e) => {
        const chip = e.target.closest('[data-free-count]');
        if(!chip || !pendingModeSelection) return;
        const count = Number(chip.dataset.freeCount || 0);
        if(!count) return;
        pendingModeSelection.freeLetterCount = count;
        setActiveChip(elFreeCountGroup, c => c === chip);
      });
    }

    if(elDifficultyGroup){
      elDifficultyGroup.addEventListener('click', (e) => {
        const chip = e.target.closest('[data-difficulty]');
        if(!chip || !pendingModeSelection) return;
        const value = chip.dataset.difficulty;
        if(!value) return;
        pendingModeSelection.difficulty = value;
        setActiveChip(elDifficultyGroup, c => c === chip);
      });
    }
    elModeDialogCancel.addEventListener('click', closeModeDialog);
    
    const elInGameDifficulty = document.getElementById('inGameDifficulty');
    if(elInGameDifficulty){
        elInGameDifficulty.addEventListener('change', (e)=>{
            const newDifficulty = e.target.value;
            saveAndApply({ difficulty: newDifficulty });
            if (game) {
                game.difficulty = newDifficulty;
            }
        });
    }

    const elModeWarningAction = document.getElementById('modeWarningAction');
    if(elModeWarningAction){
      elModeWarningAction.addEventListener('click', () => {
        switchToTab('einstellungen');
        elStatusGrid?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    }

    // Rundenanzeige
    elRounds.addEventListener('input', ()=> elRoundsOut.textContent = elRounds.value);

    // UX: Aufnahmen-Status pr√ºfen und UI aktualisieren
    const elEmptyState = document.getElementById('emptyState');
    const elProgressBadge = document.getElementById('progressBadge');

    async function updateUIForRecordingState() {
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const clips = setData && setData.clips ? setData.clips : [];
      const recordedLetters = clips.map(clip => clip.letter);
      const recordedSet = new Set(recordedLetters);
      const recordedCount = recordedSet.size;
      const hasRecordings = recordedCount > 0;

      // Spiel-Tab: Empty State anzeigen/verstecken
      elEmptyState.classList.toggle('hidden', hasRecordings);

      const progress = getProgress();
      const mode = progress?.mode || 'FREI';
      const desiredFreeCount = progress?.freeLetterCount || 4;
      const unlockedForPath = progress?.unlocked || 4;
      updateStartButtonLabel(progress);
      updateLernwegProgress(progress);

      const baseWarnings = [];
      if(hasRecordings){
        if(mode === 'FREI'){
          const targetLetters = LETTERS.slice(0, desiredFreeCount);
          const missingBase = targetLetters.filter(letter => !recordedSet.has(letter));
          if(missingBase.length){
            baseWarnings.push(desiredFreeCount === 26
              ? `F√ºr alle 26 Buchstaben fehlen noch ${missingBase.length}.`
              : `Es fehlen Aufnahmen f√ºr: ${missingBase.join(', ')}`);
          }
        } else if(mode === 'LERNWEG'){
          const requiredLetters = LETTERS.slice(0, unlockedForPath);
          const missingBase = requiredLetters.filter(letter => !recordedSet.has(letter));
          if(missingBase.length){
            baseWarnings.push(`F√ºr den Lernweg fehlen Aufnahmen f√ºr: ${missingBase.join(', ')}`);
          }
        }
      }

      const warningMessage = [...baseWarnings].join(' ');
      const canStart = hasRecordings && baseWarnings.length === 0;
      elBtnStart.disabled = !canStart;
      elBtnStart.style.opacity = canStart ? '1' : '0.5';
      elBtnStart.style.cursor = canStart ? 'pointer' : 'not-allowed';
      elBtnStart.title = canStart ? '' : (hasRecordings ? 'Bitte nimm die fehlenden Buchstaben auf, bevor du startest.' : 'Bitte nimm zuerst mindestens eine Aufnahme auf.');

      if(elModeHint){
        if(warningMessage){
          elModeHint.textContent = `‚ö†Ô∏è ${warningMessage}`;
          elModeHint.classList.remove('hidden');
        } else {
          elModeHint.textContent = '';
          elModeHint.classList.add('hidden');
        }
      }

      // Fortschrittsanzeige in Einstellungen
      elProgressBadge.textContent = `${recordedCount} von 26 Buchstaben aufgenommen`;
      elProgressBadge.classList.toggle('empty', recordedCount === 0);

      // Buchstaben-Buttons im Preview-Modus aktualisieren
      await updateLetterButtons();
    }

    // Hilfsfunktion: Set-Selector f√ºr Kinder im Spiel-Tab bef√ºllen
    async function populateSetSelector(){
      const sets = await getAllSets();
      const activeSetId = await getActiveSet();
      const selector = document.getElementById('setSelector');

      if(!selector) return; // Element existiert nicht

      selector.innerHTML = '';
      for(const set of sets) {
        const option = document.createElement('option');
        option.value = set.id;
        option.textContent = `${set.emoji} ${set.name}`;
        option.selected = set.id === activeSetId;
        selector.appendChild(option);
      }
    }

    // Hilfsfunktion: Standard-Set-Selector in Einstellungen bef√ºllen
    async function populateDefaultSetSelector(){
      const sets = await getAllSets();
      const activeSetId = await getActiveSet();
      const selector = document.getElementById('defaultSetSelector');

      if(!selector) return; // Element existiert nicht

      selector.innerHTML = '';
      for(const set of sets) {
        const option = document.createElement('option');
        option.value = set.id;
        option.textContent = `${set.emoji} ${set.name}`;
        option.selected = set.id === activeSetId;
        selector.appendChild(option);
      }
    }

    // "Jetzt Aufnahmen machen" Button
    document.getElementById('goToSettings').addEventListener('click', () => {
      switchToTab('einstellungen');
    });

    // Settings-Zahnrad Button (oben rechts)
    document.getElementById('settingsBtn').addEventListener('click', () => {
      switchToTab('einstellungen');
    });

    // Set-Selector im Spiel-Tab f√ºr Kinder
    document.getElementById('setSelector').addEventListener('change', async (e) => {
      await setActiveSet(e.target.value);
      await updateLetterButtons();
      await updateRecordingUI();
      await populateDefaultSetSelector();
    });

    // Standard-Set-Selector in Einstellungen f√ºr Erwachsene
    document.getElementById('defaultSetSelector').addEventListener('change', async (e) => {
      await setActiveSet(e.target.value);
      await renderSetsList();
      await updateLetterButtons();
      await updateRecordingUI();
      await populateSetSelector();
    });



    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // IndexedDB (Aufnahmen & Sets)
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const DB_NAME='abc-abenteuer-db';
    const STORE='recordings';
    const DB_VERSION = 2;

    let dbPromise = new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e)=> {
        const db = req.result;
        const oldVersion = e.oldVersion;

        // Version 1: Recordings Store erstellen
        if(!db.objectStoreNames.contains(STORE)) {
          db.createObjectStore(STORE);
        }

        // Version 2: Migration f√ºr Multi-Sets (wird sp√§ter bei Bedarf durchgef√ºhrt)
        // Alte "audio-X" Keys bleiben vorerst, werden bei erster Nutzung migriert
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });

    function idbGet(key){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readonly');
        const st = tx.objectStore(STORE);
        const r = st.get(key);
        r.onsuccess = ()=> res(r.result || null);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbSet(key,val){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        const st = tx.objectStore(STORE);
        const r = st.put(val,key);
        r.onsuccess = ()=> res(true);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbDel(key){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        const st = tx.objectStore(STORE);
        const r = st.delete(key);
        r.onsuccess = ()=> res(true);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbKeys(){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readonly');
        const st = tx.objectStore(STORE);
        const keys=[];
        if(st.getAllKeys){
          const r = st.getAllKeys();
          r.onsuccess = ()=> res(r.result || []);
          r.onerror = ()=> rej(r.error);
        }else{
          // Fallback √ºber Cursor
          st.openCursor().onsuccess = (e)=>{
            const cursor = e.target.result;
            if(cursor){ keys.push(cursor.key); cursor.continue(); }
            else res(keys);
          };
        }
      }));
    }
    function idbClear(){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        tx.objectStore(STORE).clear().onsuccess = ()=> res(true);
        tx.onerror = ()=> rej(tx.error);
      }));
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Set-Management
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    let currentSetId = null;

    // UUID generieren
    function generateUUID(){
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    const AUDIO_DIFFICULTIES = ['LEICHT', 'MITTEL', 'SCHWER', 'AFFIG'];

    function normaliseLetterInput(value){
      if(typeof value !== 'string') return null;
      const trimmed = value.trim().toUpperCase();
      return trimmed && /^[A-Z√Ñ√ñ√ú]$/.test(trimmed) ? trimmed : null;
    }

    function normaliseDifficultyInput(value){
      const fallback = 'LEICHT';
      if(!value) return fallback;
      const normalised = value.toString().trim().toUpperCase();
      return AUDIO_DIFFICULTIES.includes(normalised) ? normalised : fallback;
    }

    async function loadSetData(setId){
      if(!setId) return null;
      const setKey = 'set-' + setId;
      const raw = await idbGet(setKey);
      if(!raw){
        return null;
      }

      let changed = false;
      const data = {
        name: raw.name || 'Meine Aufnahmen',
        emoji: raw.emoji || 'üé§',
        created: raw.created || Date.now(),
        clips: Array.isArray(raw.clips) ? raw.clips.slice() : [],
      };

      const seen = new Set();
      data.clips = data.clips
        .filter(clip => clip && typeof clip.id === 'string' && clip.id)
        .map(clip => {
          const id = clip.id;
          if(seen.has(id)) return null;
          seen.add(id);
          const letter = normaliseLetterInput(clip.letter) || 'A';
          const difficulty = normaliseDifficultyInput(clip.difficulty);
          return {
            id,
            letter,
            difficulty,
            created: typeof clip.created === 'number' ? clip.created : Date.now(),
          };
        })
        .filter(Boolean);

      if(!Array.isArray(raw.clips) || raw.clips.length !== data.clips.length){
        changed = true;
      }

      const migrated = await migrateLegacyRecordingsForSet(setId, data);
      changed = changed || migrated;

      if(changed){
        await idbSet(setKey, data);
      }

      return data;
    }

    async function migrateLegacyRecordingsForSet(setId, setData){
      const prefix = 'audio-' + setId + '-';
      const keys = await idbKeys();
      const knownIds = new Set(setData.clips.map(clip => clip.id));
      const legacyKeys = keys.filter(key => key.startsWith(prefix));
      let updated = false;

      for(const key of legacyKeys){
        const suffix = key.slice(prefix.length);
        if(knownIds.has(suffix)){
          continue;
        }

        if(/^[A-Z√Ñ√ñ√ú]$/.test(suffix)){
          const letter = suffix;
          const blob = await idbGet(key);
          if(!blob) continue;
          const clip = {
            id: generateUUID(),
            letter,
            difficulty: 'LEICHT',
            created: Date.now(),
          };
          await idbSet('audio-' + setId + '-' + clip.id, blob);
          await idbDel(key);
          setData.clips.push(clip);
          knownIds.add(clip.id);
          updated = true;
        }
      }

      return updated;
    }

    async function createSet(name, emoji){
      const setId = generateUUID();
      const setData = {
        name: name || 'Neues Set',
        emoji: emoji || 'üé§',
        created: Date.now(),
        clips: [],
      };
      await idbSet('set-' + setId, setData);
      return setId;
    }

    // Alle Sets abrufen
    async function getAllSets(){
      const keys = await idbKeys();
      const setKeys = keys.filter(k => k.startsWith('set-'));
      const sets = [];
      for(const key of setKeys){
        const id = key.replace('set-', '');
        const data = await loadSetData(id);
        if(data){
          sets.push({ id, ...data });
        }
      }
      return sets.sort((a,b) => (a.created || 0) - (b.created || 0));
    }

    // Set l√∂schen (inkl. aller Aufnahmen)
    async function deleteSet(setId){
      // Set-Metadaten l√∂schen
      await idbDel('set-' + setId);

      // Alle Audio-Aufnahmen des Sets l√∂schen
      const keys = await idbKeys();
      const audioKeys = keys.filter(k => k.startsWith('audio-' + setId + '-'));
      for(const key of audioKeys){
        await idbDel(key);
      }
    }

    // Set umbenennen
    async function updateSet(setId, name, emoji){
      const setData = await loadSetData(setId);
      if(setData){
        setData.name = name;
        setData.emoji = emoji;
        await idbSet('set-' + setId, setData);
      }
    }

    // Aktives Set setzen
    async function setActiveSet(setId){
      currentSetId = setId;
      await idbSet('activeSet', setId);
    }

    // Aktives Set laden
    async function getActiveSet(){
      if(currentSetId) return currentSetId;
      const saved = await idbGet('activeSet');
      if(saved){
        currentSetId = saved;
        return saved;
      }
      // Kein aktives Set? Erstes verf√ºgbares Set nutzen oder Default erstellen
      const sets = await getAllSets();
      if(sets.length > 0){
        currentSetId = sets[0].id;
        await setActiveSet(currentSetId);
        return currentSetId;
      }
      // Default-Set erstellen
      const defaultId = await createSet('Meine Aufnahmen', 'üé§');
      await setActiveSet(defaultId);
      return defaultId;
    }

    // Anzahl Aufnahmen pro Set
    async function getSetRecordingCount(setId){
      const data = await loadSetData(setId);
      if(!data) return 0;
      const uniqueLetters = new Set(data.clips.map(clip => clip.letter));
      return uniqueLetters.size;
    }

    // Migration: Alte Aufnahmen (audio-X) in neues Format (audio-SETID-X) migrieren
    async function migrateOldRecordings(){
      const keys = await idbKeys();

      const oldKeys = keys.filter(k => k.startsWith('audio-') && /^[A-Z√Ñ√ñ√ú]$/.test(k.replace('audio-', '')));
      if(oldKeys.length === 0) return;

      console.log(`Migriere ${oldKeys.length} alte Aufnahmen...`);

      const migrationSetId = await createSet('Meine Aufnahmen', 'üé§');
      const setData = await loadSetData(migrationSetId) || { clips: [] };

      for(const oldKey of oldKeys){
        const letter = oldKey.replace('audio-', '');
        const blob = await idbGet(oldKey);
        if(!blob) continue;
        const clip = {
          id: generateUUID(),
          letter,
          difficulty: 'LEICHT',
          created: Date.now(),
        };
        await idbSet('audio-' + migrationSetId + '-' + clip.id, blob);
        setData.clips.push(clip);
        await idbDel(oldKey);
      }

      await idbSet('set-' + migrationSetId, setData);
      await setActiveSet(migrationSetId);

      console.log(`Migration abgeschlossen: ${oldKeys.length} Aufnahmen migriert.`);
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Sticker-Album & Belohnungssystem
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    // Sticker-Katalog: 4 Themen √ó 12 Sticker
    const STICKER_CATALOG = {
      animals: {
        name: 'Tiere',
        emoji: 'ü¶Å',
        stickers: [
          {id: 'a1', emoji: 'ü¶Å', name: 'L√∂we'},
          {id: 'a2', emoji: 'üêò', name: 'Elefant'},
          {id: 'a3', emoji: 'ü¶í', name: 'Giraffe'},
          {id: 'a4', emoji: 'ü¶ì', name: 'Zebra'},
          {id: 'a5', emoji: 'üêº', name: 'Panda'},
          {id: 'a6', emoji: 'ü¶ä', name: 'Fuchs'},
          {id: 'a7', emoji: 'üê®', name: 'Koala'},
          {id: 'a8', emoji: 'ü¶ò', name: 'K√§nguru'},
          {id: 'a9', emoji: 'üêØ', name: 'Tiger'},
          {id: 'a10', emoji: 'üêª', name: 'B√§r'},
          {id: 'a11', emoji: 'üêß', name: 'Pinguin'},
          {id: 'a12', emoji: 'ü¶â', name: 'Eule'}
        ]
      },
      space: {
        name: 'Weltraum',
        emoji: 'üöÄ',
        stickers: [
          {id: 's1', emoji: 'üöÄ', name: 'Rakete'},
          {id: 's2', emoji: 'üõ∏', name: 'UFO'},
          {id: 's3', emoji: 'üåô', name: 'Mond'},
          {id: 's4', emoji: '‚≠ê', name: 'Stern'},
          {id: 's5', emoji: 'üåü', name: 'Glitzerstern'},
          {id: 's6', emoji: 'ü™ê', name: 'Saturn'},
          {id: 's7', emoji: 'üåç', name: 'Erde'},
          {id: 's8', emoji: '‚òÑÔ∏è', name: 'Komet'},
          {id: 's9', emoji: 'üåå', name: 'Galaxie'},
          {id: 's10', emoji: 'üëæ', name: 'Alien'},
          {id: 's11', emoji: 'üõ∞Ô∏è', name: 'Satellit'},
          {id: 's12', emoji: 'üî≠', name: 'Teleskop'}
        ]
      },
      ocean: {
        name: 'Unterwasser',
        emoji: 'üê†',
        stickers: [
          {id: 'o1', emoji: 'üê†', name: 'Fisch'},
          {id: 'o2', emoji: 'üê°', name: 'Kugelfisch'},
          {id: 'o3', emoji: 'üêü', name: 'Goldfisch'},
          {id: 'o4', emoji: 'üê¨', name: 'Delfin'},
          {id: 'o5', emoji: 'üê≥', name: 'Wal'},
          {id: 'o6', emoji: 'ü¶à', name: 'Hai'},
          {id: 'o7', emoji: 'üêô', name: 'Oktopus'},
          {id: 'o8', emoji: 'ü¶Ä', name: 'Krabbe'},
          {id: 'o9', emoji: 'ü¶û', name: 'Hummer'},
          {id: 'o10', emoji: 'üêö', name: 'Muschel'},
          {id: 'o11', emoji: '‚≠ê', name: 'Seestern'},
          {id: 'o12', emoji: 'ü™∏', name: 'Koralle'}
        ]
      },
      fairy: {
        name: 'M√§rchen',
        emoji: 'üè∞',
        stickers: [
          {id: 'f1', emoji: 'üè∞', name: 'Schloss'},
          {id: 'f2', emoji: 'üëë', name: 'Krone'},
          {id: 'f3', emoji: 'üßô', name: 'Zauberer'},
          {id: 'f4', emoji: 'üßö', name: 'Fee'},
          {id: 'f5', emoji: 'üêâ', name: 'Drache'},
          {id: 'f6', emoji: 'ü¶Ñ', name: 'Einhorn'},
          {id: 'f7', emoji: 'üó°Ô∏è', name: 'Schwert'},
          {id: 'f8', emoji: 'üõ°Ô∏è', name: 'Schild'},
          {id: 'f9', emoji: 'üíé', name: 'Diamant'},
          {id: 'f10', emoji: 'üîÆ', name: 'Kristallkugel'},
          {id: 'f11', emoji: 'üìú', name: 'Schriftrolle'},
          {id: 'f12', emoji: 'ü™Ñ', name: 'Zauberstab'}
        ]
      }
    };

    // Alle Sticker-IDs sammeln
    const ALL_STICKER_IDS = Object.values(STICKER_CATALOG)
      .flatMap(theme => theme.stickers.map(s => s.id));

    // Sticker finden nach ID
    function getStickerById(stickerId){
      for(const theme of Object.values(STICKER_CATALOG)){
        const sticker = theme.stickers.find(s => s.id === stickerId);
        if(sticker) return sticker;
      }
      return null;
    }

    // Sterne abrufen
    async function getStars(){
      const stars = await idbGet('stars');
      return stars || 0;
    }

    // Sterne setzen
    async function setStars(count){
      await idbSet('stars', count);
    }

    // Sterne hinzuf√ºgen
    async function addStars(count){
      const current = await getStars();
      await setStars(current + count);
      return current + count;
    }

    // Gesammelte Sticker abrufen
    async function getCollectedStickers(){
      const stickers = await idbGet('collectedStickers');
      return stickers || [];
    }

    // Sticker hinzuf√ºgen
    async function addSticker(stickerId){
      const collected = await getCollectedStickers();
      if(!collected.includes(stickerId)){
        collected.push(stickerId);
        await idbSet('collectedStickers', collected);
        return true; // Neu gesammelt
      }
      return false; // Duplikat
    }

    // Buchstaben-Statistik abrufen
    async function getLetterStats(){
      const stats = await idbGet('letterStats');
      return stats || {}; // {A: 5, B: 3, ...}
    }

    // Buchstaben-Statistik inkrementieren
    async function incrementLetterStat(letter){
      const stats = await getLetterStats();
      stats[letter] = (stats[letter] || 0) + 1;
      await idbSet('letterStats', stats);
      return stats[letter];
    }

    // Badge-Level f√ºr Buchstabe berechnen (Bronze: 3, Silber: 10, Gold: 25)
    function getLetterBadge(count){
      if(count >= 25) return {level: 'gold', emoji: 'ü•á', name: 'Gold'};
      if(count >= 10) return {level: 'silver', emoji: 'ü•à', name: 'Silber'};
      if(count >= 3) return {level: 'bronze', emoji: 'ü•â', name: 'Bronze'};
      return null;
    }

    // Zuf√§lliges Sticker-Pack √∂ffnen (3 zuf√§llige Sticker, keine Duplikate im Pack)
    function openStickerPack(){
      const available = [...ALL_STICKER_IDS];
      const pack = [];

      // 3 zuf√§llige Sticker ziehen
      for(let i = 0; i < 3 && available.length > 0; i++){
        const randomIndex = Math.floor(Math.random() * available.length);
        const stickerId = available.splice(randomIndex, 1)[0];
        pack.push(stickerId);
      }

      return pack;
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // UI ‚Äì Set-Verwaltung
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const elSetsList = document.getElementById('setsList');
    const elBtnCreateSet = document.getElementById('btnCreateSet');

    // Sets-Liste rendern
    async function renderSetsList(){
      const sets = await getAllSets();
      const activeSetId = await getActiveSet();

      elSetsList.innerHTML = '';

      for(const set of sets){
        const count = await getSetRecordingCount(set.id);
        const isActive = set.id === activeSetId;

        const card = document.createElement('div');
        card.className = 'set-card' + (isActive ? ' active' : '');
        card.innerHTML = `
          <div class="set-actions">
            <button class="set-btn" data-action="edit" data-id="${set.id}" title="Bearbeiten">‚úèÔ∏è</button>
            <button class="set-btn" data-action="delete" data-id="${set.id}" title="L√∂schen">üóëÔ∏è</button>
          </div>
          <span class="set-emoji">${set.emoji}</span>
          <div class="set-name">${set.name}</div>
          <div class="set-count">${count} / 26 Buchstaben</div>
        `;

        // Klick auf Karte: Set aktivieren
        card.addEventListener('click', async (e) => {
          // Nicht aktivieren wenn auf Buttons geklickt wurde
          if(e.target.closest('.set-btn')) return;
          await setActiveSet(set.id);
          await renderSetsList();
          await updateRecordingUI();
          // Buchstaben-Grid im Spiel-Tab aktualisieren
          await updateLetterButtons();
          await populateSetSelector();
          await populateDefaultSetSelector();
        });

        elSetsList.appendChild(card);
      }
    }

    // Set erstellen Dialog
    elBtnCreateSet.addEventListener('click', async () => {
      const name = prompt('Name des Sets:', 'Neues Set');
      if(!name) return;

      const emoji = prompt('Emoji f√ºr das Set (z.B. üçé, üî§, üë∂):', 'üé§');
      if(emoji === null) return;

      const setId = await createSet(name, emoji || 'üé§');
      await setActiveSet(setId);
      await renderSetsList();
      await updateRecordingUI();
      await populateSetSelector();
      await populateDefaultSetSelector();
    });

    // Set-Aktionen (Bearbeiten/L√∂schen)
    elSetsList.addEventListener('click', async (e) => {
      const btn = e.target.closest('.set-btn');
      if(!btn) return;

      e.stopPropagation();

      const action = btn.dataset.action;
      const setId = btn.dataset.id;

      if(action === 'delete'){
        const sets = await getAllSets();
        if(sets.length <= 1){
          alert('Du musst mindestens ein Set behalten!');
          return;
        }

        if(confirm('Set wirklich l√∂schen? Alle Aufnahmen gehen verloren!')){
          const wasActive = (await getActiveSet()) === setId;
          await deleteSet(setId);

          // Wenn das aktive Set gel√∂scht wurde, erstes verf√ºgbares Set aktivieren
          if(wasActive){
            const remainingSets = await getAllSets();
            if(remainingSets.length > 0){
              await setActiveSet(remainingSets[0].id);
            }
          }

          await renderSetsList();
          await updateRecordingUI();
          await populateSetSelector();
          await populateDefaultSetSelector();
        }
      }

      if(action === 'edit'){
        const setData = await loadSetData(setId);
        if(!setData) return;

        const name = prompt('Name des Sets:', setData.name);
        if(name === null) return;

        const emoji = prompt('Emoji f√ºr das Set:', setData.emoji);
        if(emoji === null) return;

        await updateSet(setId, name || setData.name, emoji || setData.emoji);
        await renderSetsList();
        await populateSetSelector();
        await populateDefaultSetSelector();
      }
    });

    // Hilfsfunktion: Komplettes UI der Aufnahmen aktualisieren
    async function updateRecordingUI(){
      await updateStatusGridFromDB();
      await updateUIForRecordingState();
      if(currentLetter) await selectLetter(currentLetter);
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // UI ‚Äì Sticker-Album
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    let currentAlbumTheme = 'animals';
    async function renderAlbum(){
      const stars = await getStars();
      const collected = await getCollectedStickers();
      const collectedSet = new Set(collected);

      // Sterne anzeigen
      document.getElementById('starCount').textContent = stars;

      // Pack-Button aktivieren/deaktivieren
      const btnOpenPack = document.getElementById('btnOpenPack');
      btnOpenPack.disabled = stars < 10;

      // Themen-Tabs rendern
      const albumTabs = document.getElementById('albumTabs');
      albumTabs.innerHTML = '';
      for(const [key, theme] of Object.entries(STICKER_CATALOG)){
        const btn = document.createElement('button');
        btn.className = 'btn secondary';
        if(key === currentAlbumTheme) btn.classList.add('active');
        btn.textContent = `${theme.emoji} ${theme.name}`;
        btn.onclick = () => { currentAlbumTheme = key; renderAlbum(); };
        albumTabs.appendChild(btn);
      }

      // Sticker-Grid rendern
      const theme = STICKER_CATALOG[currentAlbumTheme];
      const albumContent = document.getElementById('albumContent');
      albumContent.innerHTML = `<div class="album-grid"></div>`;
      const grid = albumContent.querySelector('.album-grid');

      for(const sticker of theme.stickers){
        const slot = document.createElement('div');
        slot.className = 'sticker-slot';
        const hasSticker = collectedSet.has(sticker.id);
        if(hasSticker){
          slot.classList.add('collected');
          slot.textContent = sticker.emoji;
          slot.title = sticker.name;
        } else {
          slot.classList.add('locked');
          slot.textContent = '‚ùì';
          slot.title = '??? - Noch nicht gesammelt';
        }
        grid.appendChild(slot);
      }

      // Fortschritt anzeigen
      const themeCollected = theme.stickers.filter(s => collectedSet.has(s.id)).length;
      const progress = document.createElement('p');
      progress.className = 'muted';
      progress.style.marginTop = '16px';
      progress.textContent = `${themeCollected} von ${theme.stickers.length} Stickern gesammelt`;
      albumContent.appendChild(progress);
    }

    // Pack √∂ffnen
    document.getElementById('btnOpenPack').addEventListener('click', async () => {
      const stars = await getStars();
      if(stars < 10) return;

      // 10 Sterne abziehen
      await setStars(stars - 10);

      // 3 zuf√§llige Sticker ziehen
      const pack = openStickerPack();
      const newStickers = [];

      for(const stickerId of pack){
        const isNew = await addSticker(stickerId);
        if(isNew){
          newStickers.push(getStickerById(stickerId));
        }
      }

      // Simple Alert (TODO: sch√∂ne Animation)
      if(newStickers.length > 0){
        const msg = newStickers.map(s => `${s.emoji} ${s.name}`).join('\n');
        alert(`üéÅ Pack ge√∂ffnet!\n\nNeue Sticker:\n${msg}`);
      } else {
        alert('üéÅ Pack ge√∂ffnet!\n\nLeider nur Duplikate. Versuche es erneut!');
      }

      await renderAlbum();
    });

    async function onPracticeLetterClick(e) {
      const letter = e.currentTarget.getAttribute('data-letter');
      const btn = e.currentTarget;

      // Buchstaben-Animation beim Klick
      btn.classList.add('letter-bounce');
      setTimeout(()=> btn.classList.remove('letter-bounce'), 500);

      // Klick-Sound
      playClickSound();

      // Audio abspielen
      const difficulty = document.getElementById('practiceDifficulty').value;
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const clipData = await fetchClipForLetter({ setId, letter, difficulty, setData });
      if(!clipData){
        alert('Keine Aufnahme f√ºr diese Schwierigkeit gefunden.');
        return;
      }
      const url = URL.createObjectURL(clipData.blob);
      const audio = new Audio(url);
      audio.addEventListener('ended', () => URL.revokeObjectURL(url));
      audio.addEventListener('error', () => URL.revokeObjectURL(url));
      await audio.play().catch(()=>{});
    }

    async function updatePracticeLetterButtons() {
        const setId = await getActiveSet();
        const setData = await loadSetData(setId);
        if (!setData || !setData.clips) return;
        const hasSet = new Set(setData.clips.map(clip => clip.letter));
        document.querySelectorAll('#practiceLetters .btn-letter').forEach(btn => {
            const letter = btn.getAttribute('data-letter');
            btn.disabled = !hasSet.has(letter);
        });
    }

    function renderPracticeGrid() {
        const elPracticeLetters = document.getElementById('practiceLetters');
        if (!elPracticeLetters) return;
        elPracticeLetters.innerHTML = '';
        LETTERS.forEach(ch => {
            const b = document.createElement('button');
            b.className = 'btn-letter';
            b.textContent = ch;
            b.setAttribute('data-letter', ch);
            b.setAttribute('aria-label', 'Buchstabe ' + ch);
            b.addEventListener('click', onPracticeLetterClick);
            elPracticeLetters.appendChild(b);
        });
        updatePracticeLetterButtons();
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // UI ‚Äì Buchstabenraster
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    function renderLetterGrid(){
      elLetters.innerHTML='';
      LETTERS.forEach(ch=>{
        const b=document.createElement('button');
        b.className='btn-letter';
        b.textContent=ch;
        b.setAttribute('data-letter',ch);
        b.setAttribute('aria-label', 'Buchstabe ' + ch);
        b.addEventListener('click', onLetterClick);
        elLetters.appendChild(b);
      });
    }
    renderLetterGrid();

    // Buchstaben-Buttons basierend auf verf√ºgbaren Aufnahmen aktivieren/deaktivieren
    async function updateLetterButtons(){
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const hasSet = new Set((setData && setData.clips ? setData.clips : []).map(clip => clip.letter));
      const progress = getProgress();
      const unlockedCount = progress && progress.unlocked ? progress.unlocked : 4;
      const freeCount = progress && typeof progress.freeLetterCount === 'number' ? progress.freeLetterCount : 4;
      const mode = progress && progress.mode ? progress.mode : 'FREI';
      const allowedSet = mode === 'LERNWEG'
        ? new Set(LETTERS.slice(0, unlockedCount))
        : mode === 'FREI'
          ? new Set(LETTERS.slice(0, freeCount))
          : null;
      document.querySelectorAll('.btn-letter').forEach(btn => {
        const letter = btn.getAttribute('data-letter');
        let disabled = !hasSet.has(letter);
        if(!disabled && allowedSet && !allowedSet.has(letter)){
          disabled = true;
        }
        btn.disabled = disabled;
        if(allowedSet){
          btn.classList.toggle('locked', !allowedSet.has(letter));
        } else {
          btn.classList.remove('locked');
        }
      });
    }

    function setActiveChip(group, predicate){
      if(!group) return;
      let matched = false;
      group.querySelectorAll('.chip').forEach(chip => {
        const active = predicate(chip);
        chip.classList.toggle('active', active);
        if(active) matched = true;
      });
      if(!matched){
        const first = group.querySelector('.chip');
        if(first) first.classList.add('active');
      }
    }

    function applyModeToUI(progress){
      const mode = (progress && progress.mode) || 'FREI';


      if(elModeControls){
        elModeControls.classList.toggle('hidden', mode !== 'FREI');
      }

      if(mode === 'FREI'){
        const desiredCount = progress && progress.freeLetterCount ? progress.freeLetterCount : 4;
        const diff = progress && progress.difficulty ? progress.difficulty : 'LEICHT';

        setActiveChip(elFreeCountGroup, chip => Number(chip.dataset.freeLetterCount || 0) === desiredCount);
        setActiveChip(elDifficultyGroup, chip => (chip.dataset.difficulty || '') === diff);
      }

      updateModeDialogCards(extractSelectionFromProgress(progress));
      updateStartButtonLabel(progress);
    }

    const DIFFICULTY_LABELS = {
      LEICHT: 'Leicht',
      MITTEL: 'Mittel',
      SCHWER: 'Schwer',
      AFFIG: 'Affig',
    };

    const DIFFICULTY_DESCRIPTIONS = {
      LEICHT: 'Leicht (Buchstabe + Anlaut)',
      MITTEL: 'Mittel (Nur Buchstabe)',
      SCHWER: 'Schwer (Beispielwort)',
      AFFIG: 'Affig (Extra Schwer)',
    };

    const LERNWEG_STEPS = [4, 8, 12, 16, 20, 24, 26]; // Defined LERNWEG_STEPS

    function deriveLernwegMeta(progress){
      const unlockedRaw = progress && Number.isFinite(progress.unlocked) ? progress.unlocked : 4;
      const unlocked = LERNWEG_STEPS.includes(unlockedRaw)
        ? unlockedRaw
        : LERNWEG_STEPS.find(step => step > unlockedRaw) || 4;
      const stepIndex = Math.max(0, LERNWEG_STEPS.indexOf(unlocked));
      const step = stepIndex + 1;
      const completedStages = step; // Simplified, as audio sets are removed
      const percent = Math.min(100, Math.round((completedStages / LERNWEG_STEPS.length) * 100));
      const flawless = progress && Number.isFinite(progress.flawlessStreak) ? Math.max(0, progress.flawlessStreak) : 0;
      const roundsRemaining = Math.max(0, 2 - flawless);
      const atFinalStage = step >= LERNWEG_STEPS.length;
      const nextStep = stepIndex < LERNWEG_STEPS.length - 1 ? LERNWEG_STEPS[stepIndex + 1] : LERNWEG_STEPS[stepIndex];

      return {
        unlocked,
        step,
        stepTotal: LERNWEG_STEPS.length,
        percent,
        roundsRemaining,
        atFinalStage,
        nextStep,
        flawless,
      };
    }

    function updateLernwegProgress(progress){
      if(!elLernwegTrack || !elLernwegDetail || !elLernwegFill || !elLernwegNext){
        return;
      }

      if(!progress || progress.mode !== 'LERNWEG'){
        elLernwegTrack.classList.add('hidden');
        return;
      }

      const meta = deriveLernwegMeta(progress);
      elLernwegTrack.classList.remove('hidden');

      elLernwegDetail.textContent = `Stufe ${meta.step} von ${meta.stepTotal}`;
      elLernwegFill.style.width = `${meta.percent}%`;
      const progressBar = elLernwegTrack.querySelector('.lernweg-bar');
      if(progressBar){
        progressBar.setAttribute('aria-valuenow', String(meta.percent));
        progressBar.setAttribute('aria-valuetext', `Fortschritt ${meta.percent} Prozent`);
      }

      if(meta.atFinalStage){
        elLernwegNext.textContent = 'Du hast den gesamten Lernweg gemeistert! üéâ';
      }else{
        if(meta.roundsRemaining > 0){
          const suffix = meta.roundsRemaining === 1 ? 'fehlerfreie Runde' : 'fehlerfreie Runden';
          elLernwegNext.textContent = `Noch ${meta.roundsRemaining} ${suffix} bis Stufe ${meta.step + 1}.`;
        } else {
          elLernwegNext.textContent = 'Fast geschafft! Eine perfekte Runde katapultiert dich auf die n√§chste Stufe.';
        }
      }
    }

    function updateStartButtonLabel(progress){
      if(!elBtnStart) return;
      const mode = progress && progress.mode ? progress.mode : 'FREI';
      const difficulty = progress && progress.difficulty ? progress.difficulty : 'LEICHT';
      const desc = formatDifficultyLabel(difficulty);
      if(mode === 'LERNWEG'){
        elBtnStart.textContent = `Spiel starten ‚Äì Lernweg (${desc})`;
      } else {
        const count = progress && progress.freeLetterCount ? progress.freeLetterCount : 4;
        elBtnStart.textContent = `Spiel starten ‚Äì ${count} Buchstaben (${desc})`;
      }
    }

    function extractSelectionFromProgress(progress){
      const difficulty = progress && progress.difficulty ? progress.difficulty : 'LEICHT';
      return {
        mode: progress && progress.mode ? progress.mode : 'FREI',
        freeLetterCount: progress && progress.freeLetterCount ? progress.freeLetterCount : 4,
        difficulty,
      };
    }

    function toggleIndividualPanel(forceOpen){
      if(!elIndividualPanel) return;
      const shouldOpen = typeof forceOpen === 'boolean'
        ? forceOpen
        : elIndividualPanel.classList.contains('hidden');

      if(shouldOpen){
        elIndividualPanel.classList.remove('hidden');
        pendingModeSelection = extractSelectionFromProgress(getProgress());
        pendingModeSelection.mode = 'FREI';
        const desiredCount = pendingModeSelection.freeLetterCount || 4;
        const diff = pendingModeSelection.difficulty || 'LEICHT';
        setActiveChip(elFreeCountGroup, chip => Number(chip.dataset.freeCount || 0) === desiredCount);
        setActiveChip(elDifficultyGroup, chip => (chip.dataset.difficulty || '') === diff);

        updateModeDialogCards(pendingModeSelection);
        if(elModeDialogStart){
          elModeDialogStart.disabled = false;
        }
      } else {
        elIndividualPanel.classList.add('hidden');
      }
    }

    let pendingModeSelection = null;

    function updateModeDialogCards(selection){
      if(!selection) return;
      dialogModeCards.forEach(card => {
        const cardMode = card.dataset.mode || 'FREI';
        const cardCount = Number(card.dataset.count || NaN);
        let active = false;
        if(selection.mode === 'LERNWEG'){
          active = cardMode === 'LERNWEG';
        } else if(cardMode === 'FREI' && selection.mode === 'FREI'){
          if(!Number.isNaN(cardCount)){
            active = selection.freeLetterCount === cardCount;
          } else {
            active = true;
          }
        }
        card.classList.toggle('active', active);
      });
      if(elModeDialogStart){
        elModeDialogStart.disabled = !selection;
      }
    }



    function openModeDialog(){
      const currentProgress = getProgress();
      pendingModeSelection = extractSelectionFromProgress(currentProgress);

      toggleIndividualPanel(false);
      updateModeDialogCards(pendingModeSelection);
      elModeDialog.classList.remove('hidden');
    }

    function closeModeDialog(){
      elModeDialog.classList.add('hidden');
      toggleIndividualPanel(false);
      pendingModeSelection = null;
    }

    function saveAndApply(partial){
      const current = getProgress();
      const updates = { ...partial };
      if(updates.difficulty){
        updates.difficulty = updates.difficulty.toUpperCase();
      }
      const saved = saveProgress(updates);
      applyModeToUI(saved);
      updateUIForRecordingState();
      if(pendingModeSelection){
        pendingModeSelection = extractSelectionFromProgress(saved);
      }
      return saved;
    }

    function formatDifficultyLabel(difficulty){
      switch(difficulty){
        case 'MITTEL': return 'Mittel';
        case 'SCHWER': return 'Schwer';
        case 'AFFIG': return 'Affig';
        default: return 'Leicht';
      }
    }

    function formatClipTimestamp(created){
      const date = new Date(created || Date.now());
      return date.toLocaleDateString(undefined, {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit'
      });
    }

    function renderStatusGrid(hasSet=new Set(), byDifficulty=new Map()){
      elStatusGrid.innerHTML='';
      LETTERS.forEach(ch=>{
        const t=document.createElement('div');
        const hasLetter = hasSet.has(ch);
        t.className='status-tile' + (hasLetter?' has':'');
        const diffCounts = byDifficulty.get(ch);
        let badges = '';
        if(diffCounts){
          badges = '<div class="status-diffs">' + AUDIO_DIFFICULTIES.map(diff => {
            const count = diffCounts[diff] || 0;
            return `<span class="status-pill${count ? ' filled' : ''}" data-diff="${diff}">${count || ''}</span>`;
          }).join('') + '</div>';
        }
        t.innerHTML=`${ch}<i class="status-dot"></i>${badges}`;
        const summary = diffCounts ? AUDIO_DIFFICULTIES
          .filter(diff => (diffCounts[diff] || 0) > 0)
          .map(diff => `${formatDifficultyLabel(diff)} (${diffCounts[diff]})`) : [];
        const title = hasLetter ? (summary.length ? 'Aufnahmen: ' + summary.join(', ') : 'Aufnahme vorhanden') : 'Keine Aufnahme';
        t.title = title;
        t.addEventListener('click', ()=> selectLetter(ch));
        elStatusGrid.appendChild(t);
      });
    }

    function highlightClipSelection(){
      if(!elClipList) return;
      Array.from(elClipList.querySelectorAll('.clip-item')).forEach(item => {
        item.classList.toggle('active', item.dataset.clipId === currentClipId);
      });
    }

    function setCurrentClip(clipId){
      currentClipId = clipId;
      highlightClipSelection();
      const clip = currentLetterClips.find(c => c.id === clipId) || null;
      if(clip){
        elRecStatus.textContent = `${formatDifficultyLabel(clip.difficulty)} ¬∑ ${formatClipTimestamp(clip.created)}`;
      } else {
        const count = currentLetterClips.length;
        elRecStatus.textContent = count ? `${count} Aufnahme${count === 1 ? '' : 'n'} gespeichert` : 'Keine Aufnahme';
      }
      elBtnPlay.disabled = !clip;
      elBtnDelete.disabled = !clip;
    }

    function renderClipList(clips){
      currentLetterClips = clips.slice();
      const difficultyOrder = new Map(AUDIO_DIFFICULTIES.map((diff, index) => [diff, index]));
      currentLetterClips.sort((a,b) => {
        const diffCompare = (difficultyOrder.get(a.difficulty) || 0) - (difficultyOrder.get(b.difficulty) || 0);
        if(diffCompare !== 0) return diffCompare;
        return (b.created || 0) - (a.created || 0);
      });

      if(elClipList){
        elClipList.innerHTML = '';
        if(!currentLetterClips.length){
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.textContent = 'Noch keine Aufnahmen f√ºr diesen Buchstaben.';
          elClipList.appendChild(empty);
        } else {
          currentLetterClips.forEach(clip => {
            const item = document.createElement('div');
            item.className = 'clip-item';
            item.dataset.clipId = clip.id;
            item.dataset.clipDifficulty = clip.difficulty;
            item.innerHTML = `
              <div class="clip-info">
                <span class="clip-badge">${formatDifficultyLabel(clip.difficulty)}</span>
                <span class="clip-meta">${formatClipTimestamp(clip.created)}</span>
              </div>
              <div class="clip-actions">
                <button type="button" class="btn ghost" data-action="play">‚ñ∂Ô∏è</button>
                <button type="button" class="btn ghost" data-action="delete">üóëÔ∏è</button>
              </div>`;
            elClipList.appendChild(item);
          });
        }
      }

      const preferred = currentLetterClips.find(clip => clip.difficulty === currentDifficulty) || currentLetterClips[0] || null;
      setCurrentClip(preferred ? preferred.id : null);
      highlightClipSelection();
    }

    function setRecordDifficulty(difficulty, options = {}){
      currentDifficulty = difficulty;
      if(elRecordDifficultyGroup){
        Array.from(elRecordDifficultyGroup.querySelectorAll('[data-record-difficulty]')).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.recordDifficulty === difficulty);
        });
      }

      if(options.preserveSelection){
        if(options.clipId && currentLetterClips.some(clip => clip.id === options.clipId)){
          setCurrentClip(options.clipId);
        } else {
          highlightClipSelection();
        }
        return;
      }

      if(options.clipId && currentLetterClips.some(clip => clip.id === options.clipId)){
        setCurrentClip(options.clipId);
        return;
      }

      const matching = currentLetterClips.find(clip => clip.difficulty === difficulty);
      if(matching){
        setCurrentClip(matching.id);
      } else if(currentClipId && currentLetterClips.some(c => c.id === currentClipId)){
        highlightClipSelection();
      } else {
        setCurrentClip(currentLetterClips[0] ? currentLetterClips[0].id : null);
      }
    }

    function aggregateClipsByLetter(clips){
      const map = new Map();
      clips.forEach(clip => {
        const letter = clip.letter;
        if(!map.has(letter)){
          map.set(letter, {});
        }
        const entry = map.get(letter);
        entry[clip.difficulty] = (entry[clip.difficulty] || 0) + 1;
      });
      return map;
    }

    async function refreshCurrentLetterClips(){
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const clips = (setData && setData.clips ? setData.clips : []).filter(clip => clip.letter === currentLetter);
      renderClipList(clips);
      setRecordDifficulty(currentDifficulty, { preserveSelection: true, clipId: currentClipId });
      return { setId, setData };
    }

    async function persistClip(setId, letter, difficulty, blob) {
      const clipId = generateUUID();
      const clipKey = `audio-${setId}-${clipId}`;
      await idbSet(clipKey, blob);

      const setKey = `set-${setId}`;
      const setData = await idbGet(setKey) || {
        name: 'Meine Aufnahmen',
        emoji: 'üé§',
        created: Date.now(),
        clips: [],
      };

      setData.clips.push({
        id: clipId,
        letter,
        difficulty,
        created: Date.now(),
      });

      await idbSet(setKey, setData);
    }

    function pickClip(clips, difficulty) {
      if (!clips || clips.length === 0) {
        return null;
      }

      const difficulties = ['AFFIG', 'SCHWER', 'MITTEL', 'LEICHT'];
      const requestedDifficultyIndex = difficulties.indexOf(difficulty);

      // Fallback-Suche von der angeforderten Stufe abw√§rts
      if (requestedDifficultyIndex !== -1) {
        for (let i = requestedDifficultyIndex; i < difficulties.length; i++) {
          const currentDifficulty = difficulties[i];
          const matchingClips = clips.filter(c => c.difficulty === currentDifficulty);
          if (matchingClips.length > 0) {
            return matchingClips[Math.floor(Math.random() * matchingClips.length)];
          }
        }
      }

      // Wenn nichts gefunden wurde, versuche irgendeinen Clip f√ºr diesen Buchstaben
      // (z.B. wenn nur "SCHWER" existiert, aber "LEICHT" angefordert wurde)
      if (clips.length > 0) {
        return clips[Math.floor(Math.random() * clips.length)];
      }

      return null;
    }

    async function getAudio(letter, difficulty = 'LEICHT') {
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      if (!setData || !setData.clips) return null;

      const letterClips = setData.clips.filter(c => c.letter === letter);
      const clip = pickClip(letterClips, difficulty);

      if (clip) {
        const clipKey = `audio-${setId}-${clip.id}`;
        const blob = await idbGet(clipKey);
        return { clip, blob };
      }

      return null;
    }

    async function removeClip(setId, clipId){
      const setData = await loadSetData(setId);
      if(!setData) return null;
      const idx = setData.clips.findIndex(clip => clip.id === clipId);
      if(idx === -1) return null;
      const [clip] = setData.clips.splice(idx, 1);
      await idbSet('set-' + setId, setData);
      await idbDel('audio-' + setId + '-' + clipId);
      return clip;
    }

    async function getClipBlob(setId, clipId){
      return idbGet('audio-' + setId + '-' + clipId);
    }

    function difficultySearchOrder(difficulty){
      const normalised = normaliseDifficultyInput(difficulty);
      const idx = AUDIO_DIFFICULTIES.indexOf(normalised);
      const order = [];
      if(idx >= 0){
        for(let i = idx; i >= 0; i--){
          const diff = AUDIO_DIFFICULTIES[i];
          if(!order.includes(diff)) order.push(diff);
        }
      }
      if(!order.includes('LEICHT')){
        order.push('LEICHT');
      }
      return order;
    }



    async function fetchClipForLetter({ setId, letter, difficulty, setData }){
      const clips = setData.clips.filter(c => c.letter === letter);
      const clip = pickClip(clips, difficulty);
      if(!clip) return null;
      const blob = await getClipBlob(setId, clip.id);
      if(!blob) return null;
      return { clip, blob };
    }

    async function playClipById(clipId){
      const setId = await getActiveSet();
      const blob = await getClipBlob(setId, clipId);
      if(!blob){
        alert('Keine Aufnahme gefunden.');
        return;
      }
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      audio.addEventListener('ended', () => URL.revokeObjectURL(url));
      audio.addEventListener('error', () => URL.revokeObjectURL(url));
      lastPlayed = audio;
      await audio.play().catch(()=>{});
    }

    async function deleteClipById(clipId){
      const setId = await getActiveSet();
      const removed = await removeClip(setId, clipId);
      if(!removed){
        alert('Aufnahme nicht gefunden.');
        return;
      }
      if(currentClipId === clipId){
        currentClipId = null;
      }
      await refreshCurrentLetterClips();
      await updateStatusGridFromDB();
      await updateUIForRecordingState();
      await renderSetsList();
    }

    async function selectNextLetter(fromLetter){
      const letter = fromLetter || currentLetter;
      const idx = LETTERS.indexOf(letter);
      if(idx === -1){
        await selectLetter(currentLetter || 'A');
        return;
      }
      const nextLetter = LETTERS[(idx + 1) % LETTERS.length];
      await selectLetter(nextLetter);
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Recorder
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    let mediaStream=null, recorder=null, recChunks=[];
    let currentLetter='A', timerInt=null, timerStart=0, lastPlayed=null;
    let currentDifficulty='LEICHT';
    let currentClipId=null;
    let currentLetterClips=[];

    if(elRecordDifficultyGroup){
      elRecordDifficultyGroup.addEventListener('click', (event) => {
        const btn = event.target.closest('[data-record-difficulty]');
        if(!btn) return;
        event.preventDefault();
        const diff = btn.dataset.recordDifficulty || 'LEICHT';
        setRecordDifficulty(diff);
      });
    }

    if(elClipList){
      elClipList.addEventListener('click', async (event) => {
        const item = event.target.closest('.clip-item');
        if(!item) return;
        const clipId = item.dataset.clipId;
        if(!clipId) return;
        const actionBtn = event.target.closest('[data-action]');
        if(actionBtn){
          const action = actionBtn.dataset.action;
          if(action === 'play'){
            await playClipById(clipId);
          } else if(action === 'delete'){
            if(confirm('Aufnahme wirklich l√∂schen?')){
              await deleteClipById(clipId);
            }
          }
          return;
        }
        setCurrentClip(clipId);
        const diff = item.dataset.clipDifficulty;
        if(diff){
          setRecordDifficulty(diff, { preserveSelection: true, clipId });
        }
      });
    }

    setRecordDifficulty(currentDifficulty);
    selectLetter('A');
    updateStatusGridFromDB();

    async function selectLetter(ch){
      // Laufende Aufnahme stoppen, falls eine aktiv ist
      if(recorder && recorder.state === 'recording') {
        recorder.stop();
        elBtnRec.textContent = 'üéôÔ∏è Aufnehmen';
        elBtnRec.classList.remove('danger');
        clearInterval(timerInt);
        elTimer.classList.remove('blink');
        elTimer.textContent = '00:00';
      }

      currentLetter = ch;
      elRecLetter.textContent = ch;
      elRecTitle.textContent = ch;
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const clips = (setData && setData.clips ? setData.clips : []).filter(clip => clip.letter === ch);
      renderClipList(clips);
      setRecordDifficulty(currentDifficulty, { preserveSelection: true, clipId: currentClipId });
      updateStatusGridFromDB();
    }

    async function updateStatusGridFromDB(){
      const setId = await getActiveSet();
      const data = await loadSetData(setId);
      const clips = data && data.clips ? data.clips : [];
      const hasSet = new Set(clips.map(clip => clip.letter));
      const byDifficulty = aggregateClipsByLetter(clips);
      renderStatusGrid(hasSet, byDifficulty);
    }

    function fmt(t){
      const s=Math.floor(t/1000);
      const mm=String(Math.floor(s/60)).padStart(2,'0');
      const ss=String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }

    elBtnRec.addEventListener('click', async ()=>{
      // Wenn gerade aufgenommen wird: Stoppen
      if(recorder && recorder.state === 'recording') {
        recorder.stop();
        elBtnRec.textContent = 'üéôÔ∏è Aufnehmen';
        elBtnRec.classList.remove('danger');
        clearInterval(timerInt);
        elTimer.classList.remove('blink');
        elTimer.textContent = '00:00';
        return;
      }

      // Sonst: Aufnahme starten
      try{
        if(!mediaStream) mediaStream = await navigator.mediaDevices.getUserMedia({audio:true});
      }catch(e){
        alert('Mikrofonzugriff fehlgeschlagen. Bitte Browserberechtigungen pr√ºfen.');
        return;
      }
      const types = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4'];
      let mimeType = types.find(t=> window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) || '';
      recorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : undefined);
      recChunks = [];
      recorder.ondataavailable = e=> e.data && recChunks.push(e.data);
      recorder.onstop = async ()=>{
        const blob = new Blob(recChunks, {type: recorder.mimeType || 'audio/webm'});
        const recordedLetter = currentLetter;
        const recordedDifficulty = currentDifficulty;
        const setId = await getActiveSet();
        await persistClip(setId, recordedLetter, recordedDifficulty, blob);
        await selectLetter(recordedLetter); // <--- FIX: Force-refresh the current letter's UI
        await updateStatusGridFromDB();
        await updateUIForRecordingState();
        await renderSetsList();
        requestAnimationFrame(() => {
          selectNextLetter(recordedLetter).catch(err => console.error('Auto-advance failed', err));
        });
      };
      recorder.start();
      elBtnRec.textContent = '‚èπÔ∏è Stoppen';
      elBtnRec.classList.add('danger');
      elBtnPlay.disabled=true; elBtnDelete.disabled=true;
      timerStart = performance.now();
      elTimer.classList.add('blink');
      timerInt = setInterval(()=> elTimer.textContent = fmt(performance.now()-timerStart), 200);
    });

    elBtnPlay.addEventListener('click', async ()=>{
      if(!currentClipId){
        alert('Bitte zuerst eine Aufnahme ausw√§hlen oder erstellen.');
        return;
      }
      await playClipById(currentClipId);
    });

    elBtnDelete.addEventListener('click', async ()=>{
      if(!currentClipId){
        alert('Bitte zuerst eine Aufnahme ausw√§hlen.');
        return;
      }
      if(confirm('Ausgew√§hlte Aufnahme l√∂schen?')){
        await deleteClipById(currentClipId);
      }
    });

    document.getElementById('clearAll').addEventListener('click', async ()=>{
      if(confirm('Wirklich ALLE Aufnahmen l√∂schen?')){
        await idbClear();
        updateStatusGridFromDB();
        updateUIForRecordingState();
        if(currentLetter) selectLetter(currentLetter);
      }
    });

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Export/Import
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    document.getElementById('exportBtn').addEventListener('click', async ()=>{
      try{
        const sets = await getAllSets();

        if(sets.length === 0){
          alert('Keine Sets zum Exportieren vorhanden.');
          return;
        }

        const zip = new JSZip();

        // Set-Metadaten exportieren
        const setsMetadata = [];
        let totalAudio = 0;

        for(const set of sets){
          const setFolder = zip.folder(set.id);
          const clipEntries = [];

          if(Array.isArray(set.clips)){
            for(const clip of set.clips){
              const blob = await getClipBlob(set.id, clip.id);
              if(!blob){
                console.warn('Clip ohne Audiodatei, wird √ºbersprungen:', set.id, clip.id);
                continue;
              }
              const extension = blob.type.includes('webm') ? 'webm'
                : blob.type.includes('ogg') ? 'ogg'
                : blob.type.includes('mp3') ? 'mp3'
                : blob.type.includes('m4a') ? 'm4a'
                : blob.type.includes('wav') ? 'wav'
                : blob.type.includes('mp4') ? 'mp4'
                : 'audio';
              const fileName = `${clip.letter}-${clip.id}.${extension}`;
              if(setFolder){
                setFolder.file(fileName, blob);
              }
              clipEntries.push({
                id: clip.id,
                letter: clip.letter,
                difficulty: clip.difficulty,
                created: clip.created,
                file: fileName,
              });
              totalAudio++;
            }
          }

          setsMetadata.push({
            id: set.id,
            name: set.name,
            emoji: set.emoji,
            created: set.created,
            clips: clipEntries,
          });
        }

        // sets.json hinzuf√ºgen
        zip.file('sets.json', JSON.stringify(setsMetadata, null, 2));

        // ZIP generieren und herunterladen
        const content = await zip.generateAsync({type: 'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `abc-abenteuer-sets-${new Date().toISOString().split('T')[0]}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`‚úÖ ${sets.length} Set(s) mit insgesamt ${totalAudio} Aufnahmen exportiert!`);
      }catch(e){
        console.error('Export fehlgeschlagen:', e);
        alert('‚ùå Export fehlgeschlagen: ' + e.message);
      }
    });

    document.getElementById('importBtn').addEventListener('click', ()=>{
      document.getElementById('importFile').click();
    });

    document.getElementById('importFile').addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if(!file){
        return;
      }

      try{
        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        let importedSets = 0;
        let importedAudio = 0;
        let errorCount = 0;

        // Pr√ºfe ob sets.json vorhanden ist (neues Format)
        const setsJsonFile = contents.files['sets.json'];

        if(setsJsonFile){
          // Neues Format: Sets mit Metadaten & Clip-Informationen
          const setsJsonText = await setsJsonFile.async('text');
          const setsMetadata = JSON.parse(setsJsonText);

          for(const setMeta of setsMetadata){
            if(!setMeta || !setMeta.id){
              errorCount++;
              continue;
            }

            const clipList = [];
            const setPrefix = `${setMeta.id}/`;

            if(Array.isArray(setMeta.clips) && setMeta.clips.length){
              for(const clipMeta of setMeta.clips){
                const clipId = clipMeta && clipMeta.id ? clipMeta.id : generateUUID();
                const letter = normaliseLetterInput(clipMeta && clipMeta.letter ? clipMeta.letter : null) || 'A';
                const difficulty = normaliseDifficultyInput(clipMeta && clipMeta.difficulty ? clipMeta.difficulty : 'LEICHT');
                let fileName = clipMeta && clipMeta.file ? clipMeta.file : '';

                let zipEntry = null;
                if(fileName){
                  const normalizedFile = fileName.replace(/^\/+/, '');
                  zipEntry = contents.files[setPrefix + normalizedFile];
                  if(!zipEntry){
                    // Fallback: vielleicht wurde Datei ohne Unterordner exportiert
                    zipEntry = contents.files[normalizedFile];
                  }
                }
                if(!zipEntry){
                  // Fallback: Suche nach Datei, die die Clip-ID enth√§lt
                  zipEntry = Object.entries(contents.files).find(([name]) => {
                    return !name.endsWith('/') && name.startsWith(setPrefix) && name.includes(clipId);
                  });
                  if(zipEntry){
                    fileName = zipEntry[0].replace(setPrefix, '');
                    zipEntry = zipEntry[1];
                  }
                }

                if(!zipEntry || zipEntry.dir){
                  console.warn('Audio-Datei f√ºr Clip nicht gefunden:', setMeta.id, clipId);
                  errorCount++;
                  continue;
                }

                const blob = await zipEntry.async('blob');
                if(!blob.type.startsWith('audio/') && !fileName.match(/\.(webm|ogg|mp3|mp4|m4a|wav|audio)$/i)){
                  errorCount++;
                  continue;
                }

                await idbSet(`audio-${setMeta.id}-${clipId}`, blob);
                clipList.push({
                  id: clipId,
                  letter,
                  difficulty,
                  created: typeof clipMeta?.created === 'number' ? clipMeta.created : Date.now(),
                });
                importedAudio++;
              }
            } else {
              // Fallback: Keine Clip-Metadaten vorhanden ‚Üí alles als LEICHT importieren
              for(const [filename, zipEntry] of Object.entries(contents.files)){
                if(zipEntry.dir || !filename.startsWith(setPrefix)) continue;
                const rawName = filename.replace(setPrefix, '');
                if(!rawName) continue;
                const letter = normaliseLetterInput(rawName.split('.')[0]) || 'A';
                const blob = await zipEntry.async('blob');
                if(!blob.type.startsWith('audio/') && !rawName.match(/\.(webm|ogg|mp3|mp4|m4a|wav|audio)$/i)){
                  errorCount++;
                  continue;
                }
                const clipId = generateUUID();
                await idbSet(`audio-${setMeta.id}-${clipId}`, blob);
                clipList.push({
                  id: clipId,
                  letter,
                  difficulty: 'LEICHT',
                  created: Date.now(),
                });
                importedAudio++;
              }
            }

            await idbSet('set-' + setMeta.id, {
              name: setMeta.name,
              emoji: setMeta.emoji,
              created: setMeta.created || Date.now(),
              clips: clipList,
            });

            importedSets++;
          }

          alert(`‚úÖ ${importedSets} Set(s) mit ${importedAudio} Aufnahmen importiert!${errorCount > 0 ? `\n‚ö†Ô∏è ${errorCount} Dateien √ºbersprungen.` : ''}`);

        } else {
          // Altes Format: Direkte Audio-Dateien ohne Sets
          // Importiere in aktuelles Set
          const currentSetId = await getActiveSet();

          for(const [filename, zipEntry] of Object.entries(contents.files)){
            if(zipEntry.dir || filename.startsWith('__MACOSX') || filename.startsWith('.')) continue;

            const letter = filename.split('.')[0].toUpperCase();
            if(!/^[A-Z]$/.test(letter)){
              errorCount++;
              continue;
            }

            const blob = await zipEntry.async('blob');
            if(!blob.type.startsWith('audio/') && !filename.match(/\.(webm|ogg|mp3|mp4|m4a|wav)$/i)){
              errorCount++;
              continue;
            }

            const clipId = generateUUID();
            await idbSet('audio-' + currentSetId + '-' + clipId, blob);
            const setData = await loadSetData(currentSetId) || { name: 'Meine Aufnahmen', emoji: 'üé§', created: Date.now(), clips: [] };
            setData.clips.push({
              id: clipId,
              letter,
              difficulty: 'LEICHT',
              created: Date.now(),
            });
            await idbSet('set-' + currentSetId, setData);
            importedAudio++;
          }

          if(importedAudio > 0){
            alert(`‚úÖ ${importedAudio} Aufnahmen in aktuelles Set importiert!${errorCount > 0 ? `\n‚ö†Ô∏è ${errorCount} Dateien √ºbersprungen.` : ''}`);
          } else {
            alert('‚ùå Keine g√ºltigen Aufnahmen gefunden.');
          }
        }

        // UI aktualisieren
        await renderSetsList();
        await updateStatusGridFromDB();
        await updateUIForRecordingState();
        if(currentLetter) await selectLetter(currentLetter);

        // Reset file input
        e.target.value = '';

      }catch(e){
        console.error('Import fehlgeschlagen:', e);
        alert('‚ùå Import fehlgeschlagen: ' + e.message);
        e.target.value = '';
      }
    });

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Spiel-Logik
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    let game = null;

    elBtnTestAudio.addEventListener('click', ()=> { if(lastPlayed) { lastPlayed.currentTime=0; lastPlayed.play(); }});
    document.getElementById('closeModal').addEventListener('click', closeModal);

    function closeModal(){ elModal.classList.add('hidden'); }

    async function startGame(){
      const progress = getProgress();
      const mode = progress && progress.mode ? progress.mode : 'FREI';
      const unlockedCount = progress && progress.unlocked ? progress.unlocked : 4;
      const difficulty = progress && progress.difficulty ? progress.difficulty : 'LEICHT';

      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const clips = setData && setData.clips ? setData.clips : [];
      const recordedSet = new Set(clips.map(clip => clip.letter));

      if(recordedSet.size === 0){
        alert('Bitte nimm zuerst Buchstaben auf (mindestens 1).');
        return;
      }

      const recorded = Array.from(recordedSet).sort();
      let pool = recorded.slice();

      if(mode === 'LERNWEG'){
        const unlockedLetters = LETTERS.slice(0, unlockedCount);
        pool = unlockedLetters.filter(letter => recordedSet.has(letter));
        if(pool.length === 0){
          alert('F√ºr den Lernweg brauchst du Aufnahmen der freigeschalteten Buchstaben. Bitte nimm zuerst diese Buchstaben auf.');
          return;
        }
      } else {
        const desiredCount = progress && progress.freeLetterCount ? progress.freeLetterCount : 4;
        const targetLetters = LETTERS.slice(0, desiredCount);
        pool = targetLetters.filter(letter => recordedSet.has(letter));
        if(pool.length === 0){
          alert('F√ºr die gew√§hlte Buchstabenmenge fehlen Aufnahmen. Bitte passe die Auswahl an oder nimm die Buchstaben auf.');
          return;
        }
      }

      const rounds = parseInt(elRounds.value,10);
      game = {
        setId,
        recorded: pool.slice(),
        pool: pool.slice(),
        rounds,
        round: 0,
        ok: 0,
        bad: 0,
        target: null,
        busy: false,
        last: null,
        recent: [],
        progress,
        mode,
        difficulty,
        errorHistory: [],
      };
      elRoundMax.textContent = rounds;
      elOk.textContent=0; elBad.textContent=0;
      elBar.style.width='0%';
      document.getElementById('setup').classList.add('hidden');
      elHud.classList.remove('hidden');
      // sichere Tab: gehe auf "Spiel"
      document.querySelectorAll('.tabs button').forEach(b=>{
        const active = b.dataset.tab==='spiel';
        b.classList.toggle('active', active);
      });
      document.getElementById('spiel').classList.remove('hidden');
      document.getElementById('einstellungen').classList.add('hidden');

      // Runde 1
      await nextRound();
    }

    async function nextRound(){
      if(!game) return;
      game.round++;
      if(game.round > game.rounds){ return finishGame(); }
      elRoundNow.textContent = game.round;

      let pool = Array.isArray(game.pool) && game.pool.length ? game.pool : game.recorded;
      if(!pool || pool.length === 0){
        pool = game.recorded;
      }

      let pick = null;
      try {
        pick = pickNext({
          pool,
          last: game.last,
          wrongCounts: game.progress ? game.progress.wrongCounts : {},
          recent: game.recent || [],
          recentErrors: game.errorHistory || [],
        });
      } catch(err){
        console.warn('PickNext fehlgeschlagen, fallback auf erstes Element', err);
        pick = pool[0];
      }

      if(!pick){
        return finishGame();
      }

      game.target = pick;
      game.last = pick;
      game.recent = [pick, ...(game.recent || [])].slice(0, 3);
      const desiredDifficulty = game.difficulty;
      const setData = await loadSetData(game.setId);
      const clipData = await fetchClipForLetter({ setId: game.setId, letter: pick, difficulty: desiredDifficulty, setData });
      if(!clipData){
        // Aufnahme fehlt unerwartet ‚Üí Buchstabe aus Pool entfernen und weiter
        console.warn('Keine passende Aufnahme gefunden f√ºr', pick, 'in Schwierigkeit', desiredDifficulty);
        if(Array.isArray(game.pool)){
          game.pool = game.pool.filter(letter => letter !== pick);
        }
        if(!game.pool.length){
          return finishGame();
        }
        return nextRound();
      }
      const url = URL.createObjectURL(clipData.blob);
      lastPlayed = new Audio(url);
      lastPlayed.addEventListener('ended', () => URL.revokeObjectURL(url));
      lastPlayed.addEventListener('error', () => URL.revokeObjectURL(url));
      elBtnTestAudio.disabled=false;
      await lastPlayed.play().catch(()=>{}); // Autoplay-Beschr√§nkung? Der Klick auf "Spiel starten" reicht i.d.R. als Interaktion
      // Eingaben erlauben
      game.busy=false;
      // visuelles Reset
      document.querySelectorAll('.btn-letter').forEach(b=> b.disabled=false);
    }

    // Haupt-Handler f√ºr Buchstaben-Klick
    async function onLetterClick(e){
      const letter = e.currentTarget.getAttribute('data-letter');
      const btn = e.currentTarget;

      // Preview-Modus: Kein Spiel l√§uft, Sound abspielen
      if(!game){
        // Buchstaben-Animation beim Klick
        btn.classList.add('letter-bounce');
        setTimeout(()=> btn.classList.remove('letter-bounce'), 500);

        // Klick-Sound
        playClickSound();

        // Audio abspielen
        const setId = await getActiveSet();
        if(currentLetter === letter && currentClipId){ // currentLetter, currentClipId are for recorder
          await playClipById(currentClipId);
          return;
        }
        const setData = await loadSetData(setId);
        const clipData = await fetchClipForLetter({ setId, letter, difficulty: currentDifficulty, setData });
        if(!clipData){
          alert('Keine Aufnahme gefunden.');
          return;
        }
        const url = URL.createObjectURL(clipData.blob);
        const audio = new Audio(url);
        audio.addEventListener('ended', () => URL.revokeObjectURL(url));
        audio.addEventListener('error', () => URL.revokeObjectURL(url));
        await audio.play().catch(()=>{});
        return;
      }

      // Spiel-Modus: Normale Guess-Logik
      if(game.busy) return;

      // Klick-Sperre f√ºr die Dauer der Animation
      game.busy=true;

      // Buchstaben-Animation beim Klick
      btn.classList.add('letter-bounce');
      setTimeout(()=> btn.classList.remove('letter-bounce'), 500);

      // Klick-Sound
      playClickSound();

      const wrongCountsBefore = game.progress && game.progress.wrongCounts ? game.progress.wrongCounts : {};
      const wasErrorPick = (wrongCountsBefore[game.target] || 0) > 0;
      const correct = letter === game.target;
      if(correct){
        game.ok++;
        game.progress = markCorrect(game.target, letter);
        // Buchstaben-Statistik f√ºr Belohnungssystem tracken
        await incrementLetterStat(game.target);
      } else {
        game.bad++;
        game.progress = markWrong(game.target, letter);
      }

      game.errorHistory = [wasErrorPick, ...(game.errorHistory || [])].slice(0, 3);
      elOk.textContent = game.ok; elBad.textContent = game.bad;
      const progress = Math.min(100, Math.round(((game.round) / game.rounds)*100));
      elBar.style.width = progress + '%';

      // Soundeffekte f√ºr richtig/falsch
      if(correct){
        playSuccessSound();
      }else{
        playErrorSound();
      }

      // Feedback zeigen
      await showFeedback(correct, game.target);

      // n√§chste Runde
      await nextRound();
    }

    function showUnlockBanner(message){
      if(!elUnlockBanner) return;
      if(unlockBannerTimer){
        clearTimeout(unlockBannerTimer);
        unlockBannerTimer = null;
      }
      elUnlockBannerText.textContent = message;
      elUnlockBanner.classList.remove('hidden');
      requestAnimationFrame(()=>{
        elUnlockBanner.classList.add('visible');
      });
      unlockBannerTimer = setTimeout(()=>{
        elUnlockBanner.classList.remove('visible');
        unlockBannerTimer = setTimeout(()=>{
          elUnlockBanner.classList.add('hidden');
          unlockBannerTimer = null;
        }, 320);
      }, 2800);
    }

    function show(el, autoHide = true){
      el.classList.remove('hidden');
      if(autoHide){
        el.style.pointerEvents = 'none';
        return new Promise(res=> setTimeout(()=> { el.classList.add('hidden'); res(); }, 1200));
      } else {
        // Click-to-dismiss
        el.style.pointerEvents = 'auto';
        el.style.cursor = 'pointer';
        return new Promise(res=> {
          const dismiss = () => {
            el.classList.add('hidden');
            el.style.pointerEvents = 'none';
            el.style.cursor = 'default';
            el.removeEventListener('click', dismiss);
            res();
          };
          el.addEventListener('click', dismiss);
        });
      }
    }
    function showFeedback(ok, correctLetter){
      if(ok) return show(elOverlayGood, true); // Auto-hide bei Erfolg
      // Bei Fehler: Korrekten Buchstaben anzeigen + Click-to-dismiss
      elCorrectLetter.textContent = correctLetter;
      return show(elOverlayBad, false); // Muss weggeklickt werden
    }

    function finishGame(){
      const total = game.rounds;
      const ok = game.ok;
      const pct = Math.round((ok/total)*100);
      const msg = `${ok} von ${total} richtig (${pct}‚ÄØ%)`;
      const progressBefore = game && game.progress ? game.progress : null;
      if(progressBefore && progressBefore.mode === 'LERNWEG'){
        const beforeUnlocked = progressBefore.unlocked || 0;
        const advanced = advanceAfterRun({
          result: { mistakes: game.bad },
          state: progressBefore,
        });
        const saved = saveProgress(advanced);
        const unlockedIncreased = saved.unlocked > beforeUnlocked;
        if(unlockedIncreased){
          const parts = [];
          if(unlockedIncreased){
            parts.push(`${saved.unlocked} Buchstaben aktiv.`);
          }
          showUnlockBanner(parts.join(' '));
        }
        game.progress = saved;
      }
      // Pokalfarben anpassen (einfach √ºber F√ºllung)
      const cup = elModal.querySelector('#cup');
      const star = elModal.querySelector('#star');
      if(pct>=90){ cup.querySelector('path').setAttribute('fill','#ffd369'); star.setAttribute('fill','#fff176'); elResultTitle.textContent='Gold! Fantastisch ‚ú®'; }
      else if(pct>=70){ cup.querySelector('path').setAttribute('fill','#d6b36a'); star.setAttribute('fill','#ffe082'); elResultTitle.textContent='Silber! Super gemacht ü•à'; }
      else if(pct>=50){ cup.querySelector('path').setAttribute('fill','#c39a5a'); star.setAttribute('fill','#ffd54f'); elResultTitle.textContent='Bronze! Weiter so ü•â'; }
      else { cup.querySelector('path').setAttribute('fill','#c9c9c9'); star.setAttribute('fill','#e0e0e0'); elResultTitle.textContent='Stark gek√§mpft! üí™'; }
      // Sterne f√ºr richtige Antworten vergeben
      const earnedStars = ok;
      let fullMsg = msg;

      // Async-Teil f√ºr Sterne und Pack-√ñffnung
      (async () => {
        const totalStars = await addStars(earnedStars);

        // Pr√ºfen ob Pack ge√∂ffnet werden kann
        const canOpenPack = totalStars >= 10;
        let packsToOpen = 0;
        if(canOpenPack){
          packsToOpen = Math.floor(totalStars / 10);
        }

        // Erweiterte Nachricht mit Sternen
        if(earnedStars > 0){
          fullMsg += `\n‚≠ê +${earnedStars} Stern${earnedStars > 1 ? 'e' : ''}! (${totalStars} gesamt)`;
        }
        if(packsToOpen > 0){
          fullMsg += `\n\nüéÅ ${packsToOpen} Sticker-Pack${packsToOpen > 1 ? 's' : ''} verf√ºgbar!`;
        }

        const savedProgress = game && game.progress ? game.progress : progressBefore;
        if(savedProgress && savedProgress.wrongCounts){
          const trouble = Object.entries(savedProgress.wrongCounts)
            .filter(([, count]) => count > 0)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3);
          if(trouble.length){
            const tipLetters = trouble.map(([letter, count]) => `${letter} (${count}x)`);
            const tipSentence = trouble.length === 1
              ? `${tipLetters[0]} f√§llt noch schwer.`
              : `${tipLetters.join(', ')} fallen noch schwer.`;
            fullMsg += `\n\nüë®‚Äçüë©‚Äçüëß Eltern-Tipp: ${tipSentence} H√∂rt euch die Aufnahme gemeinsam an oder wiederholt den Buchstaben spielerisch.`;
          }
        }

        elResultText.textContent = fullMsg;

        // TODO: Pack-√ñffnen UI hier integrieren wenn packsToOpen > 0
      })();

      elResultText.textContent = msg;

      document.getElementById('setup').classList.remove('hidden');
      elHud.classList.add('hidden');
      elModal.classList.remove('hidden');
      // Re-attach event listener for 'again' button to ensure it's active after game finish
      document.getElementById('again').addEventListener('click', ()=> { closeModal(); startGame(); });
      game=null;

      // Zur√ºck in Preview-Modus: Buttons basierend auf Aufnahmen aktivieren
      updateLetterButtons();
    }

    async function startPracticeGame(letters) {
      if (!letters || letters.length === 0) return;

      // Switch to the game tab
      switchToTab('spiel');

      const progress = getProgress();
      const setId = await getActiveSet();

      const rounds = Math.min(15, letters.length * 2);

      game = {
        setId,
        recorded: letters.slice(),
        pool: letters.slice(),
        rounds,
        round: 0,
        ok: 0,
        bad: 0,
        target: null,
        busy: false,
        last: null,
        recent: [],
        progress,
        mode: 'FREI',
        difficulty: progress.difficulty,
        errorHistory: [],
      };

      elRounds.value = rounds;
      elRoundsOut.textContent = rounds;
      elRoundMax.textContent = rounds;
      elOk.textContent = 0;
      elBad.textContent = 0;
      elBar.style.width = '0%';
      document.getElementById('setup').classList.add('hidden');
      elHud.classList.remove('hidden');

      await nextRound();
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Zug√§nglichkeit / Kleinigkeiten
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // Tastatursteuerung: Enter/Space h√∂ren, Fokus
    elLetters.addEventListener('keydown', (e)=>{
      const btn = e.target.closest('button');
      if(!btn) return;
      if(e.key==='Enter' || e.key===' '){
        e.preventDefault(); btn.click();
      }
    });

    elBtnStart.addEventListener('click', startGame);

    // Inhalte initial
    (async function init(){
      // Migration alter Aufnahmen (falls vorhanden)
      await migrateOldRecordings();

      // Default-Set sicherstellen und UI initialisieren
      await getActiveSet();
      await renderSetsList();
      await updateStatusGridFromDB();
      await populateSetSelector();
      await populateDefaultSetSelector();
      applyModeToUI(getProgress());
      updateStartButtonLabel(getProgress());
      await updateLetterButtons();
      await updateUIForRecordingState();

      // Beim ersten Besuch: Pr√ºfen ob Aufnahmen vorhanden, sonst zu Einstellungen
      const setId = await getActiveSet();
      const setData = await loadSetData(setId);
      const hasRecordings = !!(setData && setData.clips && setData.clips.length);

      // Wenn keine Aufnahmen: Automatisch zu Einstellungen wechseln
      if (!hasRecordings) {
        switchToTab('einstellungen');
      }
    })();


    // PWA Service Worker Registrierung
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js') // Changed to absolute path
          .then(reg => console.log('Service Worker registriert:', reg))
          .catch(err => console.log('Service Worker Registrierung fehlgeschlagen:', err));
      });
    }

    // PWA Install Prompt
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      // Verhindere automatisches Anzeigen des Browser-Prompts
      e.preventDefault();
      // Speichere das Event f√ºr sp√§ter
      deferredPrompt = e;
      // Zeige eigenen Install-Button
      installBtn.classList.add('show');
      console.log('beforeinstallprompt Event gefeuert');
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) {
        return;
      }
      // Zeige Install-Prompt
      deferredPrompt.prompt();
      // Warte auf Benutzer-Entscheidung
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`Install-Prompt Ergebnis: ${outcome}`);
      // Reset
      deferredPrompt = null;
      installBtn.classList.remove('show');
    });

    window.addEventListener('appinstalled', () => {
      console.log('PWA wurde installiert');
      installBtn.classList.remove('show');
      deferredPrompt = null;
    });
  </script>
</body>
</html>
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ABCâ€‘Abenteuer â€“ HÃ¶r & Finde (Prototyp)</title>

  <!-- PWA Manifest & Theme -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <meta name="theme-color" content="#5a6ff0">

  <!-- JSZip fÃ¼r Export/Import -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      --bg:#fff8e7;
      --ink:#2d1b4e;
      --muted:#6b7896;
      --brand:#7c3aed;
      --brand-2:#fb923c;
      --brand-3:#f472b6;
      --ok:#22c55e;
      --bad:#ef4444;
      --surface:#ffffff;
      --card:#ffffff;
      --shadow: 0 12px 40px rgba(124,58,237,.15);
      --radius:20px;
      --radius-sm:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,var(--bg),#fff);
      color:var(--ink);
      font-family: ui-rounded, "SF Pro Rounded", "Segoe UI", "Arial Rounded MT Bold", system-ui, -apple-system, Arial, sans-serif;
      line-height:1.4;
    }
    header{
      position:sticky; top:0; z-index:5;
      background:linear-gradient(90deg,var(--brand),#a78bfa 50%, var(--brand-2));
      color:#fff; padding:16px 20px;
      display:flex; align-items:center; gap:12px;
      box-shadow:0 8px 24px rgba(124,58,237,.25);
    }
    header h1{font-size:20px; margin:0; letter-spacing:.3px}
    .badge{font-weight:700; background:rgba(255,255,255,.18); padding:6px 10px; border-radius:999px; font-size:12px}
    main{max-width:1100px; margin:24px auto; padding:0 16px 80px}
    .tabs{display:flex; gap:10px; margin-bottom:14px}
    .tabs button{
      border:0; padding:12px 20px; border-radius:999px; background:#f3e8ff; color:var(--ink); cursor:pointer; font-weight:800; font-size:15px;
      transition:all .2s ease;
    }
    .tabs button:hover{background:#e9d5ff; transform:scale(1.02)}
    .tabs button.active{background:var(--brand); color:#fff; box-shadow:0 4px 12px rgba(124,58,237,.3)}
    .card{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); padding:18px;
    }
    .grid-letters{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(64px,1fr)); gap:12px;
      margin-top:12px;
    }
    .btn-letter{
      aspect-ratio:1/1; border:0; border-radius:20px; background:linear-gradient(145deg,#faf5ff,#f3e8ff);
      font-size:42px; font-weight:900; color:var(--ink);
      cursor:pointer; box-shadow: 0 4px 12px rgba(124,58,237,.12), inset 0 0 0 3px #e9d5ff;
      transition:all .15s ease;
    }
    .btn-letter:hover{transform:translateY(-2px); box-shadow: 0 8px 20px rgba(124,58,237,.2), inset 0 0 0 3px var(--brand-3)}
    .btn-letter:active{transform:scale(.96)}
    .btn-letter[disabled]{opacity:.4; cursor:not-allowed; filter:grayscale(.6)}
    .hud{
      display:grid; grid-template-columns:1fr auto; align-items:center; gap:12px; margin:8px 0 14px;
    }
    .score{
      display:flex; gap:16px; font-weight:800; color:#1b2055;
    }
    .score .ok{color:var(--ok)} .score .bad{color:var(--bad)}
    .progress{
      height:10px; background:#eef0ff; border-radius:999px; overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.05);
    }
    .progress > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--brand),#7b84ff,#ff8a00); transition:width .3s ease}
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    .btn{
      border:0; padding:12px 18px; border-radius:14px; font-weight:800; cursor:pointer; font-size:15px;
      background:var(--brand); color:#fff; box-shadow:0 6px 18px rgba(124,58,237,.25);
      transition:all .2s ease;
    }
    .btn:hover{transform:translateY(-1px); box-shadow:0 8px 24px rgba(124,58,237,.35)}
    .btn:active{transform:translateY(0)}
    .btn.secondary{background:#f3e8ff; color:var(--brand)}
    .btn.secondary:hover{background:#e9d5ff}
    .btn.ghost{background:transparent; box-shadow:none; color:var(--brand)}
    .btn.danger{background:var(--bad)}
    .muted{color:var(--muted); font-size:14px}
    .hidden{display:none !important}

    /* Einstellungen */
    .settings-wrap{display:grid; grid-template-columns:1fr 370px; gap:16px}
    @media (max-width: 980px){ .settings-wrap{grid-template-columns:1fr} }
    .status-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(54px,1fr)); gap:10px}
    .status-tile{
      background:linear-gradient(145deg,#faf5ff,#f3e8ff);
      border-radius:16px; text-align:center; padding:12px 6px; position:relative; cursor:pointer; user-select:none;
      box-shadow: 0 2px 8px rgba(124,58,237,.1), inset 0 0 0 2px #e9d5ff;
      transition:all .15s ease;
      font-weight:900; font-size:28px; color:var(--ink);
    }
    .status-tile:hover{transform:translateY(-2px); box-shadow: 0 4px 12px rgba(124,58,237,.2), inset 0 0 0 2px var(--brand-3)}
    .status-tile:active{transform:scale(.98)}
    .status-dot{position:absolute; top:8px; right:8px; width:12px; height:12px; border-radius:999px; background:#d1d5db; box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}
    .status-tile.has{box-shadow: 0 2px 8px rgba(34,197,94,.15), inset 0 0 0 3px #86efac}
    .status-tile.has .status-dot{background:var(--ok); box-shadow:0 0 8px rgba(34,197,94,.4)}
    .recorder{
      position:sticky; top:86px; align-self:start; background:linear-gradient(145deg,#faf5ff,var(--surface));
      border-radius:var(--radius); box-shadow:var(--shadow); padding:18px;
      border:2px solid #f3e8ff;
    }
    .recorder h3{margin:0 0 10px; color:var(--ink)}
    .rec-letter{
      font-size:64px; font-weight:900; display:inline-flex; align-items:center; justify-content:center;
      width:92px; height:92px; border-radius:20px;
      background:linear-gradient(145deg,#fff,#f3e8ff);
      box-shadow: 0 4px 16px rgba(124,58,237,.15), inset 0 0 0 3px #e9d5ff;
    }
    .timer{font-variant-numeric:tabular-nums; font-weight:700}
    .blink{animation:blink 1s steps(1) infinite}
    @keyframes blink{50%{opacity:.35}}

    /* Overlays (Regenbogen, Monster, Pokal) */
    .overlay{
      position:fixed; inset:0; display:grid; place-items:center; background:rgba(255,255,255,.0);
      pointer-events:none; z-index:50;
    }
    .overlay .panel{
      display:grid; gap:12px; place-items:center;
      padding:12px; border-radius:20px;
      text-align:center; font-weight:900; font-size:20px; color:#1b2055;
      text-shadow:0 2px 0 #fff;
    }
    .tag{font-size:12px; font-weight:800; padding:4px 8px; border-radius:999px; background:rgba(0,0,0,.06)}
    .tada{animation:tada .8s ease both}
    @keyframes tada{
      0%{transform:scale(.8) rotate(-8deg)}
      50%{transform:scale(1.06) rotate(6deg)}
      100%{transform:scale(1) rotate(0)}
    }

    /* Buchstaben-Animation beim Klick */
    .letter-bounce{animation:letterBounce .5s ease both}
    @keyframes letterBounce{
      0%{transform:scale(1)}
      25%{transform:scale(1.15) rotate(-5deg)}
      50%{transform:scale(.95) rotate(5deg)}
      75%{transform:scale(1.05) rotate(-2deg)}
      100%{transform:scale(1) rotate(0)}
    }

    /* Puls-Animation fÃ¼r Buchstaben bei Spielstart */
    .letter-pulse{animation:letterPulse 1.2s ease-in-out infinite}
    @keyframes letterPulse{
      0%, 100%{transform:scale(1); opacity:1}
      50%{transform:scale(1.05); opacity:.85}
    }

    /* Regenbogen Zeichnen */
    .rainbow svg path{
      stroke-linecap:round;
      stroke-dasharray:1; stroke-dashoffset:1;
      animation:draw 900ms ease forwards;
    }
    .rainbow svg path:nth-child(1){animation-delay:0ms}
    .rainbow svg path:nth-child(2){animation-delay:60ms}
    .rainbow svg path:nth-child(3){animation-delay:120ms}
    .rainbow svg path:nth-child(4){animation-delay:180ms}
    .rainbow svg path:nth-child(5){animation-delay:240ms}
    .rainbow svg path:nth-child(6){animation-delay:300ms}
    @keyframes draw { to { stroke-dashoffset:0 } }

    /* Monster Wackeln */
    .monster svg .wiggle{animation:wiggle 680ms ease-in-out infinite}
    .monster svg .blink-eye{transform-origin:center; animation:blinkEye 3.2s infinite}
    @keyframes wiggle{
      0%{transform:rotate(-2deg) translateY(0)}
      50%{transform:rotate(2deg) translateY(-2px)}
      100%{transform:rotate(-2deg) translateY(0)}
    }
    @keyframes blinkEye{
      0%,10%,100%{transform:scaleY(1)}
      11%,12%{transform:scaleY(.1)}
      13%,100%{transform:scaleY(1)}
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:grid; place-items:center; z-index:60; background:rgba(0,0,0,.25)}
    .dialog{background:#fff; border-radius:24px; box-shadow:var(--shadow);
      width:min(560px,92vw); padding:20px; text-align:center}
    .dialog h3{margin:.4rem 0}
    .trophy{display:block; margin:6px auto 12px; width:160px; height:auto}
    .result-line{font-weight:900; font-size:18px}

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      .rainbow svg path,.tada,.monster svg .wiggle{animation:none !important}
    }

    /* Empty State Info Box */
    .info-box{
      background:linear-gradient(135deg,#fef3c7,#fef9e7);
      border:3px solid var(--brand-2);
      border-radius:var(--radius);
      padding:24px;
      margin-bottom:16px;
      text-align:center;
      box-shadow:0 6px 20px rgba(251,146,60,.15);
    }
    .info-box h3{margin:0 0 10px; color:var(--ink); font-size:20px}
    .info-box p{margin:10px 0; color:var(--muted); line-height:1.6; font-size:15px}
    .info-box .btn{margin-top:12px}
    .progress-badge{
      display:inline-block;
      background:linear-gradient(135deg,var(--brand),#a78bfa);
      color:#fff;
      padding:10px 20px;
      border-radius:999px;
      font-weight:900;
      font-size:17px;
      margin-bottom:14px;
      box-shadow:0 6px 16px rgba(124,58,237,.3);
    }
    .progress-badge.empty{background:#f3e8ff; color:var(--brand); border:2px solid #e9d5ff}

    footer{max-width:1100px; margin:-52px auto 32px; padding:0 16px; color:#6b7280; font-size:13px}

    /* Set-Karten */
    .set-card{
      background:linear-gradient(145deg,#fff,#f3e8ff);
      border-radius:16px; padding:14px 18px; min-width:200px;
      box-shadow:0 4px 12px rgba(124,58,237,.15), inset 0 0 0 2px #e9d5ff;
      cursor:pointer; transition:all .2s ease; position:relative;
    }
    .set-card:hover{transform:translateY(-2px); box-shadow:0 6px 18px rgba(124,58,237,.25), inset 0 0 0 2px var(--brand)}
    .set-card.active{background:linear-gradient(145deg,var(--brand),#a78bfa); color:#fff; box-shadow:0 6px 18px rgba(124,58,237,.35), inset 0 0 0 3px rgba(255,255,255,.2)}
    .set-card.active .set-emoji{text-shadow:0 2px 4px rgba(0,0,0,.2)}
    .set-card.active .set-name{font-weight:900}
    .set-card.active .set-count{color:rgba(255,255,255,.9)}
    .set-emoji{font-size:32px; margin-bottom:6px; display:block}
    .set-name{font-weight:800; font-size:16px; margin-bottom:4px}
    .set-count{font-size:13px; color:var(--muted); font-weight:600}
    .set-actions{position:absolute; top:10px; right:10px; display:flex; gap:4px; opacity:0; transition:opacity .2s}
    .set-card:hover .set-actions{opacity:1}
    .set-btn{border:0; background:rgba(255,255,255,.9); width:28px; height:28px; border-radius:50%; cursor:pointer; font-size:14px; display:grid; place-items:center; transition:all .15s}
    .set-btn:hover{transform:scale(1.1); background:#fff}
    .set-card.active .set-btn{background:rgba(255,255,255,.25); color:#fff}
    .set-card.active .set-btn:hover{background:rgba(255,255,255,.4)}

    /* Install Button */
    .install-btn{
      display:none; margin-left:auto; border:0; padding:8px 14px; border-radius:999px;
      background:rgba(255,255,255,.22); color:#fff; font-weight:700; font-size:13px;
      cursor:pointer; transition:background .2s ease; white-space:nowrap;
    }
    .install-btn:hover{background:rgba(255,255,255,.32)}
    .install-btn.show{display:block}
  </style>
</head>
<body>
  <header>
    <h1>ABCâ€‘Abenteuer Â· HÃ¶r &amp; Finde</h1>
    <span class="badge">Prototyp</span>
    <button id="installBtn" class="install-btn">ğŸ“± Installieren</button>
  </header>

  <main>
    <nav class="tabs">
      <button class="active" data-tab="spiel">Spiel</button>
      <button data-tab="album">ğŸ Mein Album</button>
      <button data-tab="einstellungen">Einstellungen</button>
    </nav>

    <!-- SPIEL -->
    <section id="spiel" class="card">
      <div id="setup">
        <!-- Info-Box bei fehlenden Aufnahmen -->
        <div id="emptyState" class="info-box hidden">
          <h3>ğŸ™ï¸ Noch keine Aufnahmen vorhanden</h3>
          <p>Um das Spiel zu starten, musst du zuerst deine Stimme fÃ¼r mindestens einen Buchstaben aufnehmen.</p>
          <button id="goToSettings" class="btn">Jetzt Aufnahmen machen</button>
        </div>

        <p class="muted">WÃ¤hle die Rundenzahl und starte. Das Spiel nutzt nur Buchstaben, fÃ¼r die <b>bereits Aufnahmen</b> vorhanden sind.</p>
        <div class="controls" style="margin:10px 0 6px">
          <label>Runden:
            <input id="rounds" type="range" min="5" max="26" value="10" step="1" style="vertical-align:middle">
            <b><span id="roundsOut">10</span></b>
          </label>
          <button id="btnStart" class="btn">Spiel starten</button>
        </div>
      </div>

      <div id="hud" class="hud hidden">
        <div class="score">
          <span>Runde <b id="roundNow">1</b>/<b id="roundMax">10</b></span>
          <span class="ok">Richtig: <b id="okCount">0</b></span>
          <span class="bad">Falsch: <b id="badCount">0</b></span>
        </div>
        <div class="progress"><i id="bar"></i></div>
        <div style="margin-top:10px">
          <button id="btnTestAudio" class="btn secondary" title="Aktuellen Buchstaben nochmals anhÃ¶ren" disabled>ğŸ”Š Nochmal anhÃ¶ren</button>
        </div>
      </div>

      <div id="letters" class="grid-letters" aria-label="Buchstaben-Auswahl"></div>
    </section>

    <!-- EINSTELLUNGEN -->
    <section id="einstellungen" class="card hidden">
      <!-- Set-Verwaltung -->
      <div style="margin-bottom:24px; padding-bottom:24px; border-bottom:2px solid #f3e8ff">
        <p><b>Aufnahme-Sets verwalten</b></p>
        <p class="muted">Erstelle verschiedene Aufnahme-Sets (z.B. "Mit WÃ¶rtern", "Nur Buchstaben", "Kinderstimme") und wechsle zwischen ihnen.</p>

        <div id="setsList" style="display:flex; gap:10px; flex-wrap:wrap; margin:16px 0"></div>

        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px">
          <button id="btnCreateSet" class="btn secondary">â• Neues Set erstellen</button>
        </div>
      </div>

      <div class="settings-wrap">
        <div>
          <p><b>Einstellungen Â· Aufnahmen</b></p>
          <div id="progressBadge" class="progress-badge empty">0 von 26 Buchstaben aufgenommen</div>
          <p class="muted">Tippe einen Buchstaben an, um ihn aufzunehmen. Deine Aufnahmen werden <b>nur lokal</b> gespeichert.</p>
          <div id="statusGrid" class="status-grid" aria-label="Aufnahmestatus"></div>
          <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center">
            <button id="exportBtn" class="btn secondary">ğŸ“¦ Exportieren</button>
            <button id="importBtn" class="btn secondary">ğŸ“¥ Importieren</button>
            <input type="file" id="importFile" accept=".zip" style="display:none">
            <button id="clearAll" class="btn danger">Alle lÃ¶schen</button>
            <span class="muted">Mikrofon benÃ¶tigt https/localhost.</span>
          </div>
        </div>

        <aside class="recorder">
          <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px">
            <div id="recLetter" class="rec-letter">A</div>
            <div>
              <h3 style="margin:.2rem 0">Aufnahme: <span id="recTitle">A</span></h3>
              <div class="muted">Status: <b id="recStatus">Keine Aufnahme</b></div>
            </div>
          </div>
          <div class="controls" style="margin:10px 0">
            <button id="btnRec" class="btn">ğŸ™ï¸ Aufnehmen</button>
            <button id="btnStop" class="btn secondary" disabled>â¹ï¸ Stop</button>
            <button id="btnPlay" class="btn secondary" disabled>â–¶ï¸ Testen</button>
            <button id="btnDelete" class="btn ghost" disabled>ğŸ—‘ï¸ LÃ¶schen</button>
            <span class="timer" id="timer">00:00</span>
          </div>
          <div class="muted">Tipp: Spreche klar und kurz (z.â€¯B. â€Bâ€œ oder â€B â€“ wie Ballâ€œ).</div>
        </aside>
      </div>
    </section>
  </main>

  <!-- Overlays: Regenbogen / Monster -->
  <div id="overlayGood" class="overlay hidden" role="alert" aria-live="assertive">
    <div class="panel rainbow tada">
      <!-- Regenbogen SVG -->
      <svg viewBox="0 0 600 320" width="320" height="170" aria-hidden="true">
        <path d="M60,280 A240,240 0 0 1 540,280" stroke="#ff3b30" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M90,280 A210,210 0 0 1 510,280" stroke="#ff9500" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M120,280 A180,180 0 0 1 480,280" stroke="#ffcc00" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M150,280 A150,150 0 0 1 450,280" stroke="#34c759" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M180,280 A120,120 0 0 1 420,280" stroke="#0bb1ff" stroke-width="26" fill="none" pathLength="1"></path>
        <path d="M210,280 A90,90 0 0 1 390,280" stroke="#af52de" stroke-width="26" fill="none" pathLength="1"></path>
      </svg>
      <div class="tag">Super! ğŸ‰</div>
    </div>
  </div>

  <div id="overlayBad" class="overlay hidden" role="alert" aria-live="assertive">
    <div class="panel monster">
      <!-- â€Generiertes" Monster als Inlineâ€‘SVG -->
      <svg viewBox="0 0 300 300" width="240" height="240" aria-label="Monster">
        <defs>
          <filter id="shadow"><feDropShadow dx="0" dy="3" stdDeviation="4" flood-color="#000" flood-opacity=".25"/></filter>
        </defs>
        <!-- KÃ¶rper -->
        <g class="wiggle" filter="url(#shadow)">
          <ellipse cx="150" cy="170" rx="100" ry="110" fill="#7b5cff"/>
          <!-- HÃ¶rner -->
          <path d="M85,85 L105,30 L125,85" fill="#ff8a00"/>
          <path d="M175,85 L195,30 L215,85" fill="#ff8a00"/>
          <!-- Augen -->
          <circle cx="115" cy="140" r="26" fill="#fff"/>
          <circle cx="185" cy="140" r="26" fill="#fff"/>
          <circle class="blink-eye" cx="115" cy="140" r="11" fill="#111"/>
          <circle class="blink-eye" cx="185" cy="140" r="11" fill="#111"/>
          <!-- Mund -->
          <rect x="105" y="190" width="90" height="30" rx="14" fill="#111"/>
          <!-- ZÃ¤hne -->
          <polygon points="115,190 125,210 135,190" fill="#fff"/>
          <polygon points="145,190 155,210 165,190" fill="#fff"/>
          <polygon points="175,190 185,210 195,190" fill="#fff"/>
          <!-- FÃ¼ÃŸe -->
          <ellipse cx="110" cy="260" rx="26" ry="10" fill="#6a52ff"/>
          <ellipse cx="190" cy="260" rx="26" ry="10" fill="#6a52ff"/>
        </g>
      </svg>
      <div class="tag">Fast! Versuch's nochmal ğŸ‘»</div>
      <div style="margin-top:16px; font-size:18px; color:#6b7896;">Das war:</div>
      <div id="correctLetter" style="font-size:72px; font-weight:900; color:var(--brand); margin-top:8px; text-shadow:0 3px 8px rgba(124,58,237,.3);">A</div>
    </div>
  </div>

  <!-- Ergebnis-Modal -->
  <div id="modal" class="modal hidden" aria-modal="true" role="dialog">
    <div class="dialog">
      <svg class="trophy" viewBox="0 0 200 200" aria-hidden="true">
        <!-- Einfacher Pokal -->
        <g id="cup">
          <rect x="80" y="130" width="40" height="20" fill="#a8875a"/>
          <rect x="60" y="150" width="80" height="12" fill="#6b5438"/>
          <path d="M70,55 h60 v50 a30,22 0 0 1 -60,0 z" fill="#d6b36a" stroke="#a8875a" stroke-width="3"/>
          <path d="M70,55 h60 v8 h-60 z" fill="#e8c675"/>
          <path d="M70,105 a30,22 0 0 0 60,0" fill="none" stroke="#855e2e" stroke-width="3" opacity=".35"/>
          <!-- Henkel -->
          <path d="M130,65 c25,0 30,30 5,38" stroke="#a8875a" stroke-width="6" fill="none"/>
          <path d="M70,65 c-25,0 -30,30 -5,38" stroke="#a8875a" stroke-width="6" fill="none"/>
          <!-- Stern -->
          <polygon id="star" points="100,82 106,94 120,96 110,105 112,118 100,112 88,118 90,105 80,96 94,94" fill="#fff176" stroke="#d6b36a"/>
        </g>
      </svg>
      <h3 id="resultTitle">Toll gemacht!</h3>
      <p class="result-line"><span id="resultText">8 von 10 richtig</span></p>
      <div class="controls" style="justify-content:center; margin-top:10px">
        <button id="again" class="btn">Nochmal spielen</button>
        <button id="closeModal" class="btn secondary">SchlieÃŸen</button>
      </div>
    </div>
  </div>

  <footer>
    <p>Made for kids ğŸ’œ Â· Alle Daten bleiben auf diesem GerÃ¤t. | <span class="muted">Bei iOS/Safari evtl. â€Mikrofon erlaubenâ€œ bestÃ¤tigen.</span></p>
  </footer>

  <script>
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // ABC-Abenteuer â€“ Logik
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Soundeffekte (Web Audio API)
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;

    function initAudioContext(){
      if(!audioCtx) audioCtx = new AudioContext();
      return audioCtx;
    }

    // Erfolgs-Sound: FrÃ¶hlicher aufsteigender Ton
    function playSuccessSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
      osc.frequency.exponentialRampToValueAtTime(783.99, ctx.currentTime + 0.1); // G5
      osc.frequency.exponentialRampToValueAtTime(1046.50, ctx.currentTime + 0.2); // C6

      gain.gain.setValueAtTime(0.3, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.4);
    }

    // Fehler-Sound: Sanfter absteigender Ton
    function playErrorSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'triangle';
      osc.frequency.setValueAtTime(329.63, ctx.currentTime); // E4
      osc.frequency.exponentialRampToValueAtTime(246.94, ctx.currentTime + 0.15); // B3

      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.3);
    }

    // Klick-Sound: Kurzer Feedback-Ton beim Buchstaben-Klick
    function playClickSound(){
      const ctx = initAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(880, ctx.currentTime); // A5

      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.08);
    }

    const LETTERS = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const elLetters = document.getElementById('letters');
    const elStatusGrid = document.getElementById('statusGrid');
    const elRecLetter = document.getElementById('recLetter');
    const elRecTitle = document.getElementById('recTitle');
    const elRecStatus = document.getElementById('recStatus');
    const elBtnRec = document.getElementById('btnRec');
    const elBtnStop = document.getElementById('btnStop');
    const elBtnPlay = document.getElementById('btnPlay');
    const elBtnDelete = document.getElementById('btnDelete');
    const elTimer = document.getElementById('timer');
    const elRoundNow = document.getElementById('roundNow');
    const elRoundMax = document.getElementById('roundMax');
    const elOk = document.getElementById('okCount');
    const elBad = document.getElementById('badCount');
    const elBar = document.getElementById('bar');
    const elHud = document.getElementById('hud');
    const elOverlayGood = document.getElementById('overlayGood');
    const elOverlayBad = document.getElementById('overlayBad');
    const elCorrectLetter = document.getElementById('correctLetter');
    const elModal = document.getElementById('modal');
    const elResultTitle = document.getElementById('resultTitle');
    const elResultText = document.getElementById('resultText');
    const elBtnStart = document.getElementById('btnStart');
    const elBtnTestAudio = document.getElementById('btnTestAudio');
    const elRounds = document.getElementById('rounds');
    const elRoundsOut = document.getElementById('roundsOut');

    // Tabs
    const tabsContainer = document.querySelector('.tabs');
    function switchToTab(tabName) {
      tabsContainer.querySelectorAll('button').forEach(b => {
        const isActive = b.dataset.tab === tabName;
        b.classList.toggle('active', isActive);
      });
      document.getElementById('spiel').classList.toggle('hidden', tabName !== 'spiel');
      document.getElementById('einstellungen').classList.toggle('hidden', tabName !== 'einstellungen');

      // Beim Wechsel zu Einstellungen: UI aktualisieren
      if (tabName === 'einstellungen') {
        renderSetsList();
        updateStatusGridFromDB();
        updateUIForRecordingState();
      }
    }

    tabsContainer.addEventListener('click', (e) => {
      const targetButton = e.target.closest('button');
      if (!targetButton) return;
      switchToTab(targetButton.dataset.tab);
    });

    // Rundenanzeige
    elRounds.addEventListener('input', ()=> elRoundsOut.textContent = elRounds.value);

    // UX: Aufnahmen-Status prÃ¼fen und UI aktualisieren
    const elEmptyState = document.getElementById('emptyState');
    const elProgressBadge = document.getElementById('progressBadge');

    async function updateUIForRecordingState() {
      const setId = await getActiveSet();
      const keys = await idbKeys();
      const prefix = 'audio-' + setId + '-';
      const recordedCount = keys.filter(k => k.startsWith(prefix)).length;
      const hasRecordings = recordedCount > 0;

      // Spiel-Tab: Empty State anzeigen/verstecken
      elEmptyState.classList.toggle('hidden', hasRecordings);

      // Button "Spiel starten" aktivieren/deaktivieren
      elBtnStart.disabled = !hasRecordings;
      if (!hasRecordings) {
        elBtnStart.style.opacity = '0.5';
        elBtnStart.style.cursor = 'not-allowed';
      } else {
        elBtnStart.style.opacity = '1';
        elBtnStart.style.cursor = 'pointer';
      }

      // Fortschrittsanzeige in Einstellungen
      elProgressBadge.textContent = `${recordedCount} von 26 Buchstaben aufgenommen`;
      elProgressBadge.classList.toggle('empty', recordedCount === 0);

      // Buchstaben-Buttons im Preview-Modus aktualisieren
      updateLetterButtons();
    }

    // "Jetzt Aufnahmen machen" Button
    document.getElementById('goToSettings').addEventListener('click', () => {
      switchToTab('einstellungen');
    });

    // Beim ersten Besuch: PrÃ¼fen ob Aufnahmen vorhanden, sonst zu Einstellungen
    (async function checkFirstVisit() {
      await updateUIForRecordingState();
      const setId = await getActiveSet();
      const keys = await idbKeys();
      const prefix = 'audio-' + setId + '-';
      const hasRecordings = keys.filter(k => k.startsWith(prefix)).length > 0;

      // Wenn keine Aufnahmen: Automatisch zu Einstellungen wechseln
      if (!hasRecordings) {
        switchToTab('einstellungen');
      }
    })();

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // IndexedDB (Aufnahmen & Sets)
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const DB_NAME='abc-abenteuer-db';
    const STORE='recordings';
    const DB_VERSION = 2;

    let dbPromise = new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e)=> {
        const db = req.result;
        const oldVersion = e.oldVersion;

        // Version 1: Recordings Store erstellen
        if(!db.objectStoreNames.contains(STORE)) {
          db.createObjectStore(STORE);
        }

        // Version 2: Migration fÃ¼r Multi-Sets (wird spÃ¤ter bei Bedarf durchgefÃ¼hrt)
        // Alte "audio-X" Keys bleiben vorerst, werden bei erster Nutzung migriert
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });

    function idbGet(key){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readonly');
        const st = tx.objectStore(STORE);
        const r = st.get(key);
        r.onsuccess = ()=> res(r.result || null);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbSet(key,val){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        const st = tx.objectStore(STORE);
        const r = st.put(val,key);
        r.onsuccess = ()=> res(true);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbDel(key){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        const st = tx.objectStore(STORE);
        const r = st.delete(key);
        r.onsuccess = ()=> res(true);
        r.onerror = ()=> rej(r.error);
      }));
    }
    function idbKeys(){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readonly');
        const st = tx.objectStore(STORE);
        const keys=[];
        if(st.getAllKeys){
          const r = st.getAllKeys();
          r.onsuccess = ()=> res(r.result || []);
          r.onerror = ()=> rej(r.error);
        }else{
          // Fallback Ã¼ber Cursor
          st.openCursor().onsuccess = (e)=>{
            const cursor = e.target.result;
            if(cursor){ keys.push(cursor.key); cursor.continue(); }
            else res(keys);
          };
        }
      }));
    }
    function idbClear(){
      return dbPromise.then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readwrite');
        tx.objectStore(STORE).clear().onsuccess = ()=> res(true);
        tx.onerror = ()=> rej(tx.error);
      }));
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Set-Management
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    let currentSetId = null;

    // UUID generieren
    function generateUUID(){
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // Neues Set erstellen
    async function createSet(name, emoji){
      const setId = generateUUID();
      const setData = {
        name: name || 'Neues Set',
        emoji: emoji || 'ğŸ¤',
        created: Date.now()
      };
      await idbSet('set-' + setId, setData);
      return setId;
    }

    // Alle Sets abrufen
    async function getAllSets(){
      const keys = await idbKeys();
      const setKeys = keys.filter(k => k.startsWith('set-'));
      const sets = [];
      for(const key of setKeys){
        const data = await idbGet(key);
        if(data){
          sets.push({
            id: key.replace('set-', ''),
            ...data
          });
        }
      }
      // Sortieren nach Erstellungsdatum
      return sets.sort((a,b) => a.created - b.created);
    }

    // Set lÃ¶schen (inkl. aller Aufnahmen)
    async function deleteSet(setId){
      // Set-Metadaten lÃ¶schen
      await idbDel('set-' + setId);

      // Alle Audio-Aufnahmen des Sets lÃ¶schen
      const keys = await idbKeys();
      const audioKeys = keys.filter(k => k.startsWith('audio-' + setId + '-'));
      for(const key of audioKeys){
        await idbDel(key);
      }
    }

    // Set umbenennen
    async function updateSet(setId, name, emoji){
      const setData = await idbGet('set-' + setId);
      if(setData){
        setData.name = name;
        setData.emoji = emoji;
        await idbSet('set-' + setId, setData);
      }
    }

    // Aktives Set setzen
    async function setActiveSet(setId){
      currentSetId = setId;
      await idbSet('activeSet', setId);
    }

    // Aktives Set laden
    async function getActiveSet(){
      if(currentSetId) return currentSetId;
      const saved = await idbGet('activeSet');
      if(saved){
        currentSetId = saved;
        return saved;
      }
      // Kein aktives Set? Erstes verfÃ¼gbares Set nutzen oder Default erstellen
      const sets = await getAllSets();
      if(sets.length > 0){
        currentSetId = sets[0].id;
        await setActiveSet(currentSetId);
        return currentSetId;
      }
      // Default-Set erstellen
      const defaultId = await createSet('Meine Aufnahmen', 'ğŸ¤');
      await setActiveSet(defaultId);
      return defaultId;
    }

    // Anzahl Aufnahmen pro Set
    async function getSetRecordingCount(setId){
      const keys = await idbKeys();
      return keys.filter(k => k.startsWith('audio-' + setId + '-')).length;
    }

    // Migration: Alte Aufnahmen (audio-X) in neues Format (audio-SETID-X) migrieren
    async function migrateOldRecordings(){
      const keys = await idbKeys();

      // PrÃ¼fe ob alte Keys (audio-X statt audio-UUID-X) vorhanden sind
      const oldKeys = keys.filter(k => {
        if(!k.startsWith('audio-')) return false;
        const parts = k.split('-');
        // Altes Format: audio-A, audio-B, etc. (2 Teile)
        // Neues Format: audio-UUID-A (3+ Teile wegen UUID mit Bindestrichen)
        return parts.length === 2 && /^[A-Z]$/.test(parts[1]);
      });

      if(oldKeys.length === 0) return; // Keine Migration nÃ¶tig

      console.log(`Migriere ${oldKeys.length} alte Aufnahmen...`);

      // Default-Set erstellen fÃ¼r Migration
      const migrationSetId = await createSet('Meine Aufnahmen', 'ğŸ¤');
      await setActiveSet(migrationSetId);

      // Alle alten Aufnahmen migrieren
      for(const oldKey of oldKeys){
        const letter = oldKey.replace('audio-', '');
        const blob = await idbGet(oldKey);
        if(blob){
          // In neuem Format speichern
          await idbSet('audio-' + migrationSetId + '-' + letter, blob);
          // Alten Key lÃ¶schen
          await idbDel(oldKey);
        }
      }

      console.log(`Migration abgeschlossen: ${oldKeys.length} Aufnahmen migriert.`);
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Sticker-Album & Belohnungssystem
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    // Sticker-Katalog: 4 Themen Ã— 12 Sticker
    const STICKER_CATALOG = {
      animals: {
        name: 'Tiere',
        emoji: 'ğŸ¦',
        stickers: [
          {id: 'a1', emoji: 'ğŸ¦', name: 'LÃ¶we'},
          {id: 'a2', emoji: 'ğŸ˜', name: 'Elefant'},
          {id: 'a3', emoji: 'ğŸ¦’', name: 'Giraffe'},
          {id: 'a4', emoji: 'ğŸ¦“', name: 'Zebra'},
          {id: 'a5', emoji: 'ğŸ¼', name: 'Panda'},
          {id: 'a6', emoji: 'ğŸ¦Š', name: 'Fuchs'},
          {id: 'a7', emoji: 'ğŸ¨', name: 'Koala'},
          {id: 'a8', emoji: 'ğŸ¦˜', name: 'KÃ¤nguru'},
          {id: 'a9', emoji: 'ğŸ¯', name: 'Tiger'},
          {id: 'a10', emoji: 'ğŸ»', name: 'BÃ¤r'},
          {id: 'a11', emoji: 'ğŸ§', name: 'Pinguin'},
          {id: 'a12', emoji: 'ğŸ¦‰', name: 'Eule'}
        ]
      },
      space: {
        name: 'Weltraum',
        emoji: 'ğŸš€',
        stickers: [
          {id: 's1', emoji: 'ğŸš€', name: 'Rakete'},
          {id: 's2', emoji: 'ğŸ›¸', name: 'UFO'},
          {id: 's3', emoji: 'ğŸŒ™', name: 'Mond'},
          {id: 's4', emoji: 'â­', name: 'Stern'},
          {id: 's5', emoji: 'ğŸŒŸ', name: 'Glitzerstern'},
          {id: 's6', emoji: 'ğŸª', name: 'Saturn'},
          {id: 's7', emoji: 'ğŸŒ', name: 'Erde'},
          {id: 's8', emoji: 'â˜„ï¸', name: 'Komet'},
          {id: 's9', emoji: 'ğŸŒŒ', name: 'Galaxie'},
          {id: 's10', emoji: 'ğŸ‘¾', name: 'Alien'},
          {id: 's11', emoji: 'ğŸ›°ï¸', name: 'Satellit'},
          {id: 's12', emoji: 'ğŸ”­', name: 'Teleskop'}
        ]
      },
      ocean: {
        name: 'Unterwasser',
        emoji: 'ğŸ ',
        stickers: [
          {id: 'o1', emoji: 'ğŸ ', name: 'Fisch'},
          {id: 'o2', emoji: 'ğŸ¡', name: 'Kugelfisch'},
          {id: 'o3', emoji: 'ğŸŸ', name: 'Goldfisch'},
          {id: 'o4', emoji: 'ğŸ¬', name: 'Delfin'},
          {id: 'o5', emoji: 'ğŸ³', name: 'Wal'},
          {id: 'o6', emoji: 'ğŸ¦ˆ', name: 'Hai'},
          {id: 'o7', emoji: 'ğŸ™', name: 'Oktopus'},
          {id: 'o8', emoji: 'ğŸ¦€', name: 'Krabbe'},
          {id: 'o9', emoji: 'ğŸ¦', name: 'Hummer'},
          {id: 'o10', emoji: 'ğŸš', name: 'Muschel'},
          {id: 'o11', emoji: 'â­', name: 'Seestern'},
          {id: 'o12', emoji: 'ğŸª¸', name: 'Koralle'}
        ]
      },
      fairy: {
        name: 'MÃ¤rchen',
        emoji: 'ğŸ°',
        stickers: [
          {id: 'f1', emoji: 'ğŸ°', name: 'Schloss'},
          {id: 'f2', emoji: 'ğŸ‘‘', name: 'Krone'},
          {id: 'f3', emoji: 'ğŸ§™', name: 'Zauberer'},
          {id: 'f4', emoji: 'ğŸ§š', name: 'Fee'},
          {id: 'f5', emoji: 'ğŸ‰', name: 'Drache'},
          {id: 'f6', emoji: 'ğŸ¦„', name: 'Einhorn'},
          {id: 'f7', emoji: 'ğŸ—¡ï¸', name: 'Schwert'},
          {id: 'f8', emoji: 'ğŸ›¡ï¸', name: 'Schild'},
          {id: 'f9', emoji: 'ğŸ’', name: 'Diamant'},
          {id: 'f10', emoji: 'ğŸ”®', name: 'Kristallkugel'},
          {id: 'f11', emoji: 'ğŸ“œ', name: 'Schriftrolle'},
          {id: 'f12', emoji: 'ğŸª„', name: 'Zauberstab'}
        ]
      }
    };

    // Alle Sticker-IDs sammeln
    const ALL_STICKER_IDS = Object.values(STICKER_CATALOG)
      .flatMap(theme => theme.stickers.map(s => s.id));

    // Sticker finden nach ID
    function getStickerById(stickerId){
      for(const theme of Object.values(STICKER_CATALOG)){
        const sticker = theme.stickers.find(s => s.id === stickerId);
        if(sticker) return sticker;
      }
      return null;
    }

    // Sterne abrufen
    async function getStars(){
      const stars = await idbGet('stars');
      return stars || 0;
    }

    // Sterne setzen
    async function setStars(count){
      await idbSet('stars', count);
    }

    // Sterne hinzufÃ¼gen
    async function addStars(count){
      const current = await getStars();
      await setStars(current + count);
      return current + count;
    }

    // Gesammelte Sticker abrufen
    async function getCollectedStickers(){
      const stickers = await idbGet('collectedStickers');
      return stickers || [];
    }

    // Sticker hinzufÃ¼gen
    async function addSticker(stickerId){
      const collected = await getCollectedStickers();
      if(!collected.includes(stickerId)){
        collected.push(stickerId);
        await idbSet('collectedStickers', collected);
        return true; // Neu gesammelt
      }
      return false; // Duplikat
    }

    // Buchstaben-Statistik abrufen
    async function getLetterStats(){
      const stats = await idbGet('letterStats');
      return stats || {}; // {A: 5, B: 3, ...}
    }

    // Buchstaben-Statistik inkrementieren
    async function incrementLetterStat(letter){
      const stats = await getLetterStats();
      stats[letter] = (stats[letter] || 0) + 1;
      await idbSet('letterStats', stats);
      return stats[letter];
    }

    // Badge-Level fÃ¼r Buchstabe berechnen (Bronze: 3, Silber: 10, Gold: 25)
    function getLetterBadge(count){
      if(count >= 25) return {level: 'gold', emoji: 'ğŸ¥‡', name: 'Gold'};
      if(count >= 10) return {level: 'silver', emoji: 'ğŸ¥ˆ', name: 'Silber'};
      if(count >= 3) return {level: 'bronze', emoji: 'ğŸ¥‰', name: 'Bronze'};
      return null;
    }

    // ZufÃ¤lliges Sticker-Pack Ã¶ffnen (3 zufÃ¤llige Sticker, keine Duplikate im Pack)
    function openStickerPack(){
      const available = [...ALL_STICKER_IDS];
      const pack = [];

      // 3 zufÃ¤llige Sticker ziehen
      for(let i = 0; i < 3 && available.length > 0; i++){
        const randomIndex = Math.floor(Math.random() * available.length);
        const stickerId = available.splice(randomIndex, 1)[0];
        pack.push(stickerId);
      }

      return pack;
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // UI â€“ Set-Verwaltung
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const elSetsList = document.getElementById('setsList');
    const elBtnCreateSet = document.getElementById('btnCreateSet');

    // Sets-Liste rendern
    async function renderSetsList(){
      const sets = await getAllSets();
      const activeSetId = await getActiveSet();

      elSetsList.innerHTML = '';

      for(const set of sets){
        const count = await getSetRecordingCount(set.id);
        const isActive = set.id === activeSetId;

        const card = document.createElement('div');
        card.className = 'set-card' + (isActive ? ' active' : '');
        card.innerHTML = `
          <div class="set-actions">
            <button class="set-btn" data-action="edit" data-id="${set.id}" title="Bearbeiten">âœï¸</button>
            <button class="set-btn" data-action="delete" data-id="${set.id}" title="LÃ¶schen">ğŸ—‘ï¸</button>
          </div>
          <span class="set-emoji">${set.emoji}</span>
          <div class="set-name">${set.name}</div>
          <div class="set-count">${count} / 26 Buchstaben</div>
        `;

        // Klick auf Karte: Set aktivieren
        card.addEventListener('click', async (e) => {
          // Nicht aktivieren wenn auf Buttons geklickt wurde
          if(e.target.closest('.set-btn')) return;
          await setActiveSet(set.id);
          await renderSetsList();
          await updateRecordingUI();
        });

        elSetsList.appendChild(card);
      }
    }

    // Set erstellen Dialog
    elBtnCreateSet.addEventListener('click', async () => {
      const name = prompt('Name des Sets:', 'Neues Set');
      if(!name) return;

      const emoji = prompt('Emoji fÃ¼r das Set (z.B. ğŸ, ğŸ”¤, ğŸ‘¶):', 'ğŸ¤');
      if(emoji === null) return;

      const setId = await createSet(name, emoji || 'ğŸ¤');
      await setActiveSet(setId);
      await renderSetsList();
      await updateRecordingUI();
    });

    // Set-Aktionen (Bearbeiten/LÃ¶schen)
    elSetsList.addEventListener('click', async (e) => {
      const btn = e.target.closest('.set-btn');
      if(!btn) return;

      e.stopPropagation();

      const action = btn.dataset.action;
      const setId = btn.dataset.id;

      if(action === 'delete'){
        const sets = await getAllSets();
        if(sets.length <= 1){
          alert('Du musst mindestens ein Set behalten!');
          return;
        }

        if(confirm('Set wirklich lÃ¶schen? Alle Aufnahmen gehen verloren!')){
          const wasActive = (await getActiveSet()) === setId;
          await deleteSet(setId);

          // Wenn das aktive Set gelÃ¶scht wurde, erstes verfÃ¼gbares Set aktivieren
          if(wasActive){
            const remainingSets = await getAllSets();
            if(remainingSets.length > 0){
              await setActiveSet(remainingSets[0].id);
            }
          }

          await renderSetsList();
          await updateRecordingUI();
        }
      }

      if(action === 'edit'){
        const setData = await idbGet('set-' + setId);
        if(!setData) return;

        const name = prompt('Name des Sets:', setData.name);
        if(name === null) return;

        const emoji = prompt('Emoji fÃ¼r das Set:', setData.emoji);
        if(emoji === null) return;

        await updateSet(setId, name || setData.name, emoji || setData.emoji);
        await renderSetsList();
      }
    });

    // Hilfsfunktion: Komplettes UI der Aufnahmen aktualisieren
    async function updateRecordingUI(){
      await updateStatusGridFromDB();
      await updateUIForRecordingState();
      if(currentLetter) await selectLetter(currentLetter);
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // UI â€“ Buchstabenraster
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    function renderLetterGrid(){
      elLetters.innerHTML='';
      LETTERS.forEach(ch=>{
        const b=document.createElement('button');
        b.className='btn-letter';
        b.textContent=ch;
        b.setAttribute('data-letter',ch);
        b.setAttribute('aria-label', 'Buchstabe ' + ch);
        b.addEventListener('click', onLetterClick);
        elLetters.appendChild(b);
      });
    }
    renderLetterGrid();

    // Buchstaben-Buttons basierend auf verfÃ¼gbaren Aufnahmen aktivieren/deaktivieren
    async function updateLetterButtons(){
      const setId = await getActiveSet();
      const keys = await idbKeys();
      const prefix = 'audio-' + setId + '-';
      const hasSet = new Set(
        keys.filter(k => k.startsWith(prefix))
           .map(k => k.replace(prefix, ''))
      );
      document.querySelectorAll('.btn-letter').forEach(btn => {
        const letter = btn.getAttribute('data-letter');
        btn.disabled = !hasSet.has(letter);
      });
    }

    // Status-Grid fÃ¼r Einstellungen
    function renderStatusGrid(hasSet=new Set()){
      elStatusGrid.innerHTML='';
      LETTERS.forEach(ch=>{
        const t=document.createElement('div');
        t.className='status-tile' + (hasSet.has(ch)?' has':'');
        t.innerHTML=`${ch}<i class="status-dot"></i>`;
        t.title = hasSet.has(ch) ? 'Aufnahme vorhanden' : 'Keine Aufnahme';
        t.addEventListener('click', ()=> selectLetter(ch));
        elStatusGrid.appendChild(t);
      });
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Recorder
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    let mediaStream=null, recorder=null, recChunks=[];
    let currentLetter='A', timerInt=null, timerStart=0, lastPlayed=null;

    selectLetter('A');
    updateStatusGridFromDB();

    async function selectLetter(ch){
      currentLetter = ch;
      elRecLetter.textContent = ch;
      elRecTitle.textContent = ch;
      const setId = await getActiveSet();
      const blob = await idbGet('audio-' + setId + '-' + ch);
      const has = !!blob;
      elRecStatus.textContent = has ? 'Aufnahme gespeichert' : 'Keine Aufnahme';
      elBtnPlay.disabled = !has;
      elBtnDelete.disabled = !has;
      // Markierung im Statusgrid aktualisieren (sanft)
      updateStatusGridFromDB();
    }

    async function updateStatusGridFromDB(){
      const setId = await getActiveSet();
      const keys = await idbKeys();
      // Nur Aufnahmen des aktiven Sets berÃ¼cksichtigen
      const prefix = 'audio-' + setId + '-';
      const hasSet = new Set(
        keys.filter(k => k.startsWith(prefix))
           .map(k => k.replace(prefix, ''))
      );
      renderStatusGrid(hasSet);
      // Update Startbutton aktivierbar?
      const count = hasSet.size;
      elBtnStart.disabled = count < 3;
      elBtnStart.title = count < 3 ? 'Mindestens 3 Aufnahmen empfehlen sich fÃ¼r den Start' : '';
    }

    function fmt(t){
      const s=Math.floor(t/1000);
      const mm=String(Math.floor(s/60)).padStart(2,'0');
      const ss=String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }

    elBtnRec.addEventListener('click', async ()=>{
      try{
        if(!mediaStream) mediaStream = await navigator.mediaDevices.getUserMedia({audio:true});
      }catch(e){
        alert('Mikrofonzugriff fehlgeschlagen. Bitte Browserberechtigungen prÃ¼fen.');
        return;
      }
      const types = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4'];
      let mimeType = types.find(t=> window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) || '';
      recorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : undefined);
      recChunks = [];
      recorder.ondataavailable = e=> e.data && recChunks.push(e.data);
      recorder.onstop = async ()=>{
        const blob = new Blob(recChunks, {type: recorder.mimeType || 'audio/webm'});
        const setId = await getActiveSet();
        await idbSet('audio-' + setId + '-' + currentLetter, blob);
        elRecStatus.textContent='Aufnahme gespeichert';
        elBtnPlay.disabled=false; elBtnDelete.disabled=false;
        updateStatusGridFromDB();
        updateUIForRecordingState();
        renderSetsList();
      };
      recorder.start();
      elBtnRec.disabled=true; elBtnStop.disabled=false; elBtnPlay.disabled=true; elBtnDelete.disabled=true;
      timerStart = performance.now();
      elTimer.classList.add('blink');
      timerInt = setInterval(()=> elTimer.textContent = fmt(performance.now()-timerStart), 200);
    });

    elBtnStop.addEventListener('click', ()=>{
      if(recorder && recorder.state==='recording') recorder.stop();
      elBtnRec.disabled=false; elBtnStop.disabled=true;
      clearInterval(timerInt); elTimer.classList.remove('blink'); elTimer.textContent='00:00';
    });

    elBtnPlay.addEventListener('click', async ()=>{
      const setId = await getActiveSet();
      const blob = await idbGet('audio-' + setId + '-' + currentLetter);
      if(!blob){ alert('Keine Aufnahme gefunden.'); return; }
      const url = URL.createObjectURL(blob);
      const a = new Audio(url);
      a.play();
    });

    elBtnDelete.addEventListener('click', async ()=>{
      if(confirm('Aufnahme fÃ¼r "'+currentLetter+'" lÃ¶schen?')){
        const setId = await getActiveSet();
        await idbDel('audio-' + setId + '-' + currentLetter);
        elRecStatus.textContent='Keine Aufnahme';
        elBtnPlay.disabled=true; elBtnDelete.disabled=true;
        updateStatusGridFromDB();
        updateUIForRecordingState();
        renderSetsList();
      }
    });

    document.getElementById('clearAll').addEventListener('click', async ()=>{
      if(confirm('Wirklich ALLE Aufnahmen lÃ¶schen?')){
        await idbClear();
        updateStatusGridFromDB();
        updateUIForRecordingState();
        if(currentLetter) selectLetter(currentLetter);
      }
    });

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Export/Import
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    document.getElementById('exportBtn').addEventListener('click', async ()=>{
      try{
        const sets = await getAllSets();

        if(sets.length === 0){
          alert('Keine Sets zum Exportieren vorhanden.');
          return;
        }

        const zip = new JSZip();

        // Set-Metadaten exportieren
        const setsMetadata = [];
        let totalAudio = 0;

        for(const set of sets){
          setsMetadata.push({
            id: set.id,
            name: set.name,
            emoji: set.emoji,
            created: set.created
          });

          // Alle Aufnahmen des Sets exportieren
          const keys = await idbKeys();
          const prefix = 'audio-' + set.id + '-';
          const audioKeys = keys.filter(k => k.startsWith(prefix));

          const setFolder = zip.folder(set.id);

          for(const key of audioKeys){
            const blob = await idbGet(key);
            if(blob){
              const letter = key.replace(prefix, '');
              const extension = blob.type.includes('webm') ? 'webm' :
                              blob.type.includes('ogg') ? 'ogg' :
                              blob.type.includes('mp4') ? 'mp4' : 'audio';
              setFolder.file(`${letter}.${extension}`, blob);
              totalAudio++;
            }
          }
        }

        // sets.json hinzufÃ¼gen
        zip.file('sets.json', JSON.stringify(setsMetadata, null, 2));

        // ZIP generieren und herunterladen
        const content = await zip.generateAsync({type: 'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `abc-abenteuer-sets-${new Date().toISOString().split('T')[0]}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`âœ… ${sets.length} Set(s) mit insgesamt ${totalAudio} Aufnahmen exportiert!`);
      }catch(e){
        console.error('Export fehlgeschlagen:', e);
        alert('âŒ Export fehlgeschlagen: ' + e.message);
      }
    });

    document.getElementById('importBtn').addEventListener('click', ()=>{
      document.getElementById('importFile').click();
    });

    document.getElementById('importFile').addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if(!file){
        return;
      }

      try{
        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        let importedSets = 0;
        let importedAudio = 0;
        let errorCount = 0;

        // PrÃ¼fe ob sets.json vorhanden ist (neues Format)
        const setsJsonFile = contents.files['sets.json'];

        if(setsJsonFile){
          // Neues Format: Sets mit Metadaten
          const setsJsonText = await setsJsonFile.async('text');
          const setsMetadata = JSON.parse(setsJsonText);

          for(const setMeta of setsMetadata){
            // Set erstellen
            await idbSet('set-' + setMeta.id, {
              name: setMeta.name,
              emoji: setMeta.emoji,
              created: setMeta.created
            });

            // Aufnahmen des Sets importieren
            const setPrefix = setMeta.id + '/';
            for(const [filename, zipEntry] of Object.entries(contents.files)){
              if(zipEntry.dir || !filename.startsWith(setPrefix)) continue;

              const letter = filename.replace(setPrefix, '').split('.')[0].toUpperCase();
              if(!/^[A-Z]$/.test(letter)) continue;

              const blob = await zipEntry.async('blob');
              if(!blob.type.startsWith('audio/') && !filename.match(/\.(webm|ogg|mp3|mp4|m4a|wav)$/i)){
                errorCount++;
                continue;
              }

              await idbSet('audio-' + setMeta.id + '-' + letter, blob);
              importedAudio++;
            }

            importedSets++;
          }

          alert(`âœ… ${importedSets} Set(s) mit ${importedAudio} Aufnahmen importiert!${errorCount > 0 ? `\nâš ï¸ ${errorCount} Dateien Ã¼bersprungen.` : ''}`);

        } else {
          // Altes Format: Direkte Audio-Dateien ohne Sets
          // Importiere in aktuelles Set
          const currentSetId = await getActiveSet();

          for(const [filename, zipEntry] of Object.entries(contents.files)){
            if(zipEntry.dir || filename.startsWith('__MACOSX') || filename.startsWith('.')) continue;

            const letter = filename.split('.')[0].toUpperCase();
            if(!/^[A-Z]$/.test(letter)){
              errorCount++;
              continue;
            }

            const blob = await zipEntry.async('blob');
            if(!blob.type.startsWith('audio/') && !filename.match(/\.(webm|ogg|mp3|mp4|m4a|wav)$/i)){
              errorCount++;
              continue;
            }

            await idbSet('audio-' + currentSetId + '-' + letter, blob);
            importedAudio++;
          }

          if(importedAudio > 0){
            alert(`âœ… ${importedAudio} Aufnahmen in aktuelles Set importiert!${errorCount > 0 ? `\nâš ï¸ ${errorCount} Dateien Ã¼bersprungen.` : ''}`);
          } else {
            alert('âŒ Keine gÃ¼ltigen Aufnahmen gefunden.');
          }
        }

        // UI aktualisieren
        await renderSetsList();
        await updateStatusGridFromDB();
        await updateUIForRecordingState();
        if(currentLetter) await selectLetter(currentLetter);

        // Reset file input
        e.target.value = '';

      }catch(e){
        console.error('Import fehlgeschlagen:', e);
        alert('âŒ Import fehlgeschlagen: ' + e.message);
        e.target.value = '';
      }
    });

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Spiel-Logik
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    let game = null;

    elBtnStart.addEventListener('click', startGame);
    elBtnTestAudio.addEventListener('click', ()=> { if(lastPlayed) { lastPlayed.currentTime=0; lastPlayed.play(); }});
    document.getElementById('again').addEventListener('click', ()=> { closeModal(); startGame(); });
    document.getElementById('closeModal').addEventListener('click', closeModal);

    function closeModal(){ elModal.classList.add('hidden'); }

    async function startGame(){
      // stelle sicher, dass es genug Buchstaben gibt
      const setId = await getActiveSet();
      const keys = await idbKeys();
      const prefix = 'audio-' + setId + '-';
      const set = new Set(
        keys.filter(k => k.startsWith(prefix))
           .map(k => k.replace(prefix, ''))
      );
      if(set.size===0){ alert('Bitte nimm zuerst Buchstaben auf (mindestens 1).'); return; }
      const rounds = parseInt(elRounds.value,10);
      game = {
        setId,
        recorded: Array.from(set),
        rounds,
        round: 0,
        ok: 0,
        bad: 0,
        target: null,
        busy: false
      };
      elRoundMax.textContent = rounds;
      elOk.textContent=0; elBad.textContent=0;
      elBar.style.width='0%';
      document.getElementById('setup').classList.add('hidden');
      elHud.classList.remove('hidden');
      // sichere Tab: gehe auf "Spiel"
      document.querySelectorAll('.tabs button').forEach(b=>{
        const active = b.dataset.tab==='spiel';
        b.classList.toggle('active', active);
      });
      document.getElementById('spiel').classList.remove('hidden');
      document.getElementById('einstellungen').classList.add('hidden');

      // Runde 1
      await nextRound();
    }

    async function nextRound(){
      if(!game) return;
      game.round++;
      if(game.round > game.rounds){ return finishGame(); }
      elRoundNow.textContent = game.round;
      // neuen Zielbuchstaben ziehen
      const pick = game.recorded[Math.floor(Math.random()*game.recorded.length)];
      game.target = pick;
      // Audio abspielen
      const blob = await idbGet('audio-' + game.setId + '-' + pick);
      if(!blob){
        // falls unerwartet weg, sofort nÃ¤chste Runde
        return nextRound();
      }
      const url = URL.createObjectURL(blob);
      lastPlayed = new Audio(url);
      elBtnTestAudio.disabled=false;
      await lastPlayed.play().catch(()=>{}); // Autoplay-BeschrÃ¤nkung? Der Klick auf "Spiel starten" reicht i.d.R. als Interaktion
      // Eingaben erlauben
      game.busy=false;
      // visuelles Reset
      document.querySelectorAll('.btn-letter').forEach(b=> b.disabled=false);
    }

    // Haupt-Handler fÃ¼r Buchstaben-Klick
    async function onLetterClick(e){
      const letter = e.currentTarget.getAttribute('data-letter');
      const btn = e.currentTarget;

      // Preview-Modus: Kein Spiel lÃ¤uft, Sound abspielen
      if(!game){
        // Buchstaben-Animation beim Klick
        btn.classList.add('letter-bounce');
        setTimeout(()=> btn.classList.remove('letter-bounce'), 500);

        // Klick-Sound
        playClickSound();

        // Audio abspielen
        const setId = await getActiveSet();
        const blob = await idbGet('audio-' + setId + '-' + letter);
        if(!blob) return;
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        await audio.play().catch(()=>{});
        return;
      }

      // Spiel-Modus: Normale Guess-Logik
      if(game.busy) return;

      // Klick-Sperre fÃ¼r die Dauer der Animation
      game.busy=true;

      // Buchstaben-Animation beim Klick
      btn.classList.add('letter-bounce');
      setTimeout(()=> btn.classList.remove('letter-bounce'), 500);

      // Klick-Sound
      playClickSound();

      const correct = letter === game.target;
      if(correct){
        game.ok++;
        // Buchstaben-Statistik fÃ¼r Belohnungssystem tracken
        await incrementLetterStat(game.target);
      } else {
        game.bad++;
      }
      elOk.textContent = game.ok; elBad.textContent = game.bad;
      const progress = Math.min(100, Math.round(((game.round) / game.rounds)*100));
      elBar.style.width = progress + '%';

      // Soundeffekte fÃ¼r richtig/falsch
      if(correct){
        playSuccessSound();
      }else{
        playErrorSound();
      }

      // Feedback zeigen
      await showFeedback(correct, game.target);

      // nÃ¤chste Runde
      await nextRound();
    }

    function show(el){
      el.classList.remove('hidden');
      return new Promise(res=> setTimeout(()=> { el.classList.add('hidden'); res(); }, 1200));
    }
    function showFeedback(ok, correctLetter){
      if(ok) return show(elOverlayGood);
      // Bei Fehler: Korrekten Buchstaben anzeigen
      elCorrectLetter.textContent = correctLetter;
      return show(elOverlayBad);
    }

    function finishGame(){
      const total = game.rounds;
      const ok = game.ok;
      const pct = Math.round((ok/total)*100);
      const msg = `${ok} von ${total} richtig (${pct}â€¯%)`;
      // Pokalfarben anpassen (einfach Ã¼ber FÃ¼llung)
      const cup = elModal.querySelector('#cup');
      const star = elModal.querySelector('#star');
      if(pct>=90){ cup.querySelector('path').setAttribute('fill','#ffd369'); star.setAttribute('fill','#fff176'); elResultTitle.textContent='Gold! Fantastisch âœ¨'; }
      else if(pct>=70){ cup.querySelector('path').setAttribute('fill','#d6b36a'); star.setAttribute('fill','#ffe082'); elResultTitle.textContent='Silber! Super gemacht ğŸ¥ˆ'; }
      else if(pct>=50){ cup.querySelector('path').setAttribute('fill','#c39a5a'); star.setAttribute('fill','#ffd54f'); elResultTitle.textContent='Bronze! Weiter so ğŸ¥‰'; }
      else { cup.querySelector('path').setAttribute('fill','#c9c9c9'); star.setAttribute('fill','#e0e0e0'); elResultTitle.textContent='Stark gekÃ¤mpft! ğŸ’ª'; }
      // Sterne fÃ¼r richtige Antworten vergeben
      const earnedStars = ok;
      let fullMsg = msg;

      // Async-Teil fÃ¼r Sterne und Pack-Ã–ffnung
      (async () => {
        const totalStars = await addStars(earnedStars);

        // PrÃ¼fen ob Pack geÃ¶ffnet werden kann
        const canOpenPack = totalStars >= 10;
        let packsToOpen = 0;
        if(canOpenPack){
          packsToOpen = Math.floor(totalStars / 10);
        }

        // Erweiterte Nachricht mit Sternen
        if(earnedStars > 0){
          fullMsg += `\nâ­ +${earnedStars} Stern${earnedStars > 1 ? 'e' : ''}! (${totalStars} gesamt)`;
        }
        if(packsToOpen > 0){
          fullMsg += `\n\nğŸ ${packsToOpen} Sticker-Pack${packsToOpen > 1 ? 's' : ''} verfÃ¼gbar!`;
        }

        elResultText.textContent = fullMsg;

        // TODO: Pack-Ã–ffnen UI hier integrieren wenn packsToOpen > 0
      })();

      elResultText.textContent = msg;

      document.getElementById('setup').classList.remove('hidden');
      elHud.classList.add('hidden');
      elModal.classList.remove('hidden');
      game=null;

      // ZurÃ¼ck in Preview-Modus: Buttons basierend auf Aufnahmen aktivieren
      updateLetterButtons();
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // ZugÃ¤nglichkeit / Kleinigkeiten
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // Tastatursteuerung: Enter/Space hÃ¶ren, Fokus
    elLetters.addEventListener('keydown', (e)=>{
      const btn = e.target.closest('button');
      if(!btn) return;
      if(e.key==='Enter' || e.key===' '){
        e.preventDefault(); btn.click();
      }
    });

    // Inhalte initial
    (async function init(){
      // Migration alter Aufnahmen (falls vorhanden)
      await migrateOldRecordings();

      // Default-Set sicherstellen und UI initialisieren
      await getActiveSet();
      await renderSetsList();
      await updateStatusGridFromDB();
    })();


    // PWA Service Worker Registrierung
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(reg => console.log('Service Worker registriert:', reg))
          .catch(err => console.log('Service Worker Registrierung fehlgeschlagen:', err));
      });
    }

    // PWA Install Prompt
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      // Verhindere automatisches Anzeigen des Browser-Prompts
      e.preventDefault();
      // Speichere das Event fÃ¼r spÃ¤ter
      deferredPrompt = e;
      // Zeige eigenen Install-Button
      installBtn.classList.add('show');
      console.log('beforeinstallprompt Event gefeuert');
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) {
        return;
      }
      // Zeige Install-Prompt
      deferredPrompt.prompt();
      // Warte auf Benutzer-Entscheidung
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`Install-Prompt Ergebnis: ${outcome}`);
      // Reset
      deferredPrompt = null;
      installBtn.classList.remove('show');
    });

    window.addEventListener('appinstalled', () => {
      console.log('PWA wurde installiert');
      installBtn.classList.remove('show');
      deferredPrompt = null;
    });
  </script>
</body>
</html>
